package com.jetbrains.jetpad.vclang.typechecking.termination;

/*Generated by MPS */

import com.jetbrains.jetpad.vclang.core.context.param.DependentLink;
import com.jetbrains.jetpad.vclang.core.context.param.EmptyDependentLink;
import com.jetbrains.jetpad.vclang.core.context.param.SingleDependentLink;
import com.jetbrains.jetpad.vclang.core.definition.ClassField;
import com.jetbrains.jetpad.vclang.core.definition.Constructor;
import com.jetbrains.jetpad.vclang.core.definition.Definition;
import com.jetbrains.jetpad.vclang.core.definition.FunctionDefinition;
import com.jetbrains.jetpad.vclang.core.elimtree.BranchElimTree;
import com.jetbrains.jetpad.vclang.core.elimtree.ElimTree;
import com.jetbrains.jetpad.vclang.core.elimtree.LeafElimTree;
import com.jetbrains.jetpad.vclang.core.expr.*;
import com.jetbrains.jetpad.vclang.core.expr.visitor.ExpressionVisitor;
import com.jetbrains.jetpad.vclang.core.expr.visitor.NormalizeVisitor;
import com.jetbrains.jetpad.vclang.core.internal.FieldSet;
import com.jetbrains.jetpad.vclang.core.pattern.elimtree.*;
import com.jetbrains.jetpad.vclang.core.pattern.elimtree.visitor.ElimTreeNodeVisitor;
import com.jetbrains.jetpad.vclang.core.subst.ExprSubstitution;
import com.jetbrains.jetpad.vclang.core.subst.LevelSubstitution;
import com.jetbrains.jetpad.vclang.core.subst.SubstVisitor;
import com.jetbrains.jetpad.vclang.term.Prelude;
import com.jetbrains.jetpad.vclang.typechecking.termination.CollectCallVisitor.ParameterVector;

import java.util.*;

public class CollectCallVisitor implements ElimTreeNodeVisitor<ParameterVector, Void>, ExpressionVisitor<ParameterVector, Void> {
  private Set<BaseCallMatrix<Definition>> myCollectedCalls = new HashSet<>();
  private FunctionDefinition myDefinition;
  private Set<? extends Definition> myCycle;

  CollectCallVisitor(FunctionDefinition def, Set<? extends Definition> cycle) {
    myDefinition = def;
    myCycle = cycle;
    ParameterVector pv = new ParameterVector(def);
    if (def.getElimTree() != null) {
      pv.doCollectCalls(def.getElimTree(), this);
    }
  }

  public Set<BaseCallMatrix<Definition>> getResult() {
    return myCollectedCalls;
  }

  private static BaseCallMatrix.R isLess(Expression expr1, Expression expr2) {
    if (expr2.toConCall() == null) {
      return expr1.equals(expr2) ? BaseCallMatrix.R.Equal : BaseCallMatrix.R.Unknown;
    }
    if (expr1.toConCall() != null && expr1.toConCall().getDefinition() == expr2.toConCall().getDefinition()) {
      BaseCallMatrix.R ord = isLess(expr1.toConCall().getDefCallArguments(), expr2.toConCall().getDefCallArguments());
      if (ord != BaseCallMatrix.R.Unknown) return ord;
    }
    for (Expression arg : expr2.toConCall().getDefCallArguments()) {
      if (isLess(expr1, arg) != BaseCallMatrix.R.Unknown) return BaseCallMatrix.R.LessThan;
    }
    return BaseCallMatrix.R.Unknown;
  }

  private static BaseCallMatrix.R isLess(List<? extends Expression> exprs1, List<? extends Expression> exprs2) {
    for (int i = 0; i < Math.min(exprs1.size(), exprs2.size()); i++) {
      BaseCallMatrix.R ord = isLess(exprs1.get(i), exprs2.get(i));
      if (ord != BaseCallMatrix.R.Equal) return ord;
    }
    return exprs1.size() >= exprs2.size() ? BaseCallMatrix.R.Equal : BaseCallMatrix.R.Unknown;
  }

  private BaseCallMatrix.R compare(Expression argument, Expression sample) {
    // strip currentExpression of App & Proj calls
    boolean f;
    do {
      f = false;
      if (argument instanceof AppExpression) {
        argument = ((AppExpression) argument).getFunction();
        f = true;
      }
      if (argument instanceof ProjExpression) {
        argument = ((ProjExpression) argument).getExpression();
        f = true;
      }
      if (argument instanceof FunCallExpression && ((FunCallExpression) argument).getDefinition() == Prelude.AT) {
        argument = ((FunCallExpression) argument).getDefCallArguments().get(3);
        f = true;
      }
    } while (f);

    return isLess(argument, sample);
  }

  private void collectCall(DefCallExpression expression, ParameterVector vector) {
    if (myCycle != null && !myCycle.contains(expression.getDefinition())) return;

    BaseCallMatrix<Definition> cm = new CallMatrix(myDefinition, expression);
    assert (cm.getHeight() == vector.getHeight());
    for (int i = 0; i < vector.getHeight(); i++) {
      for (int j = 0; j < expression.getDefCallArguments().size(); j++) {
        cm.set(i, j, compare(expression.getDefCallArguments().get(j), vector.getParameter(i)));
      }
    }
    myCollectedCalls.add(cm);
  }

  @Override
  public Void visitFunCall(FunCallExpression expression, ParameterVector vector) {
    collectCall(expression, vector);

    for (Expression argument : expression.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitConCall(ConCallExpression expression, ParameterVector vector) {
    // Cycles consisting of constructors are currently unsupported
    /*
    Constructor constructor = expression.getDefinition();
    if (constructor.getDataType().getCondition(constructor) != null) {
      collectCall(expression, vector);
    }
    */
    for (Expression argument : expression.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitApp(AppExpression expression, ParameterVector vector) {
    expression.getFunction().accept(this, vector);
    expression.getArgument().accept(this, vector);
    return null;
  }

  @Override
  public Void visitLet(LetExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);

    for (LetClause lc : expression.getClauses()) {
      lc.getResultType().getExpr().accept(this, vector);
      for (SingleDependentLink link : lc.getParameters()) {
        visitDependentLink(link, vector);
      }
      lc.getElimTree().accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitCase(CaseExpression expr, ParameterVector vector) {
    expr.getElimTree().accept(this, vector);
    expr.getResultType().accept(this, vector);
    for (Expression argument : expr.getArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitDataCall(DataCallExpression expression, ParameterVector vector) {
    for (Expression e : expression.getDefCallArguments()) {
      e.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitFieldCall(FieldCallExpression expression, ParameterVector vector) {
    for (Expression e : expression.getDefCallArguments()) {
      e.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitClassCall(ClassCallExpression expression, ParameterVector vector) {
    for (Map.Entry<ClassField, FieldSet.Implementation> i : expression.getFieldSet().getImplemented()) {
      i.getValue().term.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitLetClauseCall(LetClauseCallExpression expr, ParameterVector vector) {
    for (Expression argument : expr.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  private void visitDependentLink(DependentLink link, ParameterVector vector) {
    for (; link.hasNext(); link = link.getNext()) {
      link = link.getNextTyped(null);
      link.getType().getExpr().accept(this, vector);
    }
  }

  @Override
  public Void visitLam(LamExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    expression.getBody().accept(this, vector);
    return null;
  }

  @Override
  public Void visitPi(PiExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    expression.getCodomain().accept(this, vector);
    return null;
  }

  @Override
  public Void visitSigma(SigmaExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    return null;
  }

  @Override
  public Void visitTuple(TupleExpression expression, ParameterVector vector) {
    for (Expression e : expression.getFields()) {
      e.accept(this, vector);
    }

    expression.getSigmaType().accept(this, vector);
    return null;
  }

  @Override
  public Void visitProj(ProjExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);
    return null;
  }

  @Override
  public Void visitNew(NewExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);
    return null;
  }

  @Override
  public Void visitUniverse(UniverseExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitError(ErrorExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitEmpty(EmptyElimTreeNode node, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitReference(ReferenceExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitInferenceReference(InferenceReferenceExpression expression, ParameterVector vector) {
    throw new IllegalStateException();
  }

  @Override
  public Void visitOfType(OfTypeExpression expression, ParameterVector vector) {
    throw new IllegalStateException();
  }

  @Override
  public Void visitBranch(BranchElimTreeNode node, ParameterVector vector) {
    for (ConstructorClause clause : node.getConstructorClauses()) {
      clause.getChild().accept(this, new ParameterVector(vector, clause));
    }
    return null;
  }

  @Override
  public Void visitLeaf(LeafElimTreeNode node, ParameterVector vector) {
    node.getExpression().accept(this, vector);
    return null;
  }

  public static class ParameterVector {
    private Expression[] myParts;
    private List<DependentLink> myLinks;

    ParameterVector(FunctionDefinition def) {
      int paramCount = def.getNumberOfRequiredArguments();
      myParts = new Expression[paramCount];
      myLinks = new LinkedList<>();

      int i = 0;
      DependentLink dl = def.getParameters();
      while (!(dl instanceof EmptyDependentLink)) {
        myParts[i] = new ReferenceExpression(dl);
        myLinks.add(dl);
        dl = dl.getNext();
        i++;
      }
    }

    void doCollectCalls(ElimTree elimTree, CollectCallVisitor collectCallVisitor) {
      if (elimTree instanceof LeafElimTree) {
        LeafElimTree leafElimTree = (LeafElimTree) elimTree;
        leafElimTree.getExpression().accept(collectCallVisitor, this);
      } else if (elimTree instanceof BranchElimTree) {
        BranchElimTree branchElimTree = (BranchElimTree) elimTree;
        DependentLink dl = branchElimTree.getParameters();
        List<DependentLink> links2 = new LinkedList<>();
        links2.addAll(myLinks);
        while (!(dl instanceof EmptyDependentLink)) { //skip parameters that are not changed
          assert (links2.get(0) == dl);
          links2.remove(0);
          dl = dl.getNext();
        }
        for (Map.Entry<BranchElimTree.Pattern, ElimTree> entry : branchElimTree.getChildren()) {
          ParameterVector newpv;
          if (entry.getKey().equals(BranchElimTree.Pattern.ANY)) {
            newpv = this;
          } else if (entry.getKey() instanceof Constructor) {
            Constructor cons = (Constructor) entry.getKey();
            ExprSubstitution exprSubst = new ExprSubstitution();

            List<DependentLink> newpvList = new LinkedList<>();
            List<Expression> refList = new ArrayList<>();

            dl = cons.getParameters();
            while (!(dl instanceof EmptyDependentLink)) {
              newpvList.add(dl);
              refList.add(new ReferenceExpression(dl));
              dl = dl.getNext();
            }
            DependentLink current = links2.get(0);
            newpvList.addAll(links2.subList(1, links2.size()));

            DataCallExpression dataCall = current.getType().getExpr().normalize(NormalizeVisitor.Mode.WHNF).toDataCall();
            exprSubst.add(current, new ConCallExpression(cons, dataCall.getSortArgument(), cons.matchDataTypeArguments(new ArrayList<>(dataCall.getDefCallArguments())), refList));
            newpv = new ParameterVector(this, new SubstVisitor(exprSubst, LevelSubstitution.EMPTY));
            newpv.myLinks = newpvList;
            //TODO: entry.getValue() bindings are unrelated with "cons" bindings for some reason -- fix this somehow
          } else throw new IllegalStateException();
          newpv.doCollectCalls(entry.getValue(), collectCallVisitor);
        }
      }
    }

    ParameterVector(ParameterVector pv, SubstVisitor sv) {
      myParts = new Expression[pv.myParts.length];
      for (int i = 0; i < pv.myParts.length; i++) {
        myParts[i] = pv.myParts[i].accept(sv, null);
      }
    }

    ParameterVector(ParameterVector pv, Clause c) {
      this(pv, new SubstVisitor(c.getSubst(), LevelSubstitution.EMPTY));
    }

    Expression getParameter(int i) {
      return myParts[i];
    }

    int getHeight() {
      return myParts.length;
    }
  }

}
