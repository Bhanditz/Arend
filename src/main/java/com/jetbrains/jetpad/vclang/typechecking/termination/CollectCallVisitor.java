package com.jetbrains.jetpad.vclang.typechecking.termination;

/*Generated by MPS */

import com.jetbrains.jetpad.vclang.core.context.param.DependentLink;
import com.jetbrains.jetpad.vclang.core.context.param.EmptyDependentLink;
import com.jetbrains.jetpad.vclang.core.context.param.SingleDependentLink;
import com.jetbrains.jetpad.vclang.core.definition.ClassField;
import com.jetbrains.jetpad.vclang.core.definition.Definition;
import com.jetbrains.jetpad.vclang.core.definition.FunctionDefinition;
import com.jetbrains.jetpad.vclang.core.expr.*;
import com.jetbrains.jetpad.vclang.core.expr.visitor.ExpressionVisitor;
import com.jetbrains.jetpad.vclang.core.internal.FieldSet;
import com.jetbrains.jetpad.vclang.core.pattern.elimtree.*;
import com.jetbrains.jetpad.vclang.core.pattern.elimtree.visitor.ElimTreeNodeVisitor;
import com.jetbrains.jetpad.vclang.core.subst.LevelSubstitution;
import com.jetbrains.jetpad.vclang.core.subst.SubstVisitor;
import com.jetbrains.jetpad.vclang.term.Prelude;
import com.jetbrains.jetpad.vclang.typechecking.termination.CollectCallVisitor.ParameterVector;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class CollectCallVisitor implements ElimTreeNodeVisitor<ParameterVector, Void>, ExpressionVisitor<ParameterVector, Void> {
  private Set<BaseCallMatrix<Definition>> myCollectedCalls = new HashSet<>();
  private FunctionDefinition myDefinition;
  private Set<? extends Definition> myCycle;

  CollectCallVisitor(FunctionDefinition def, Set<? extends Definition> cycle) {
    myDefinition = def;
    myCycle = cycle;
    ParameterVector pv = new ParameterVector(def);
    if (def.getElimTree() != null) {
      def.getElimTree().accept(this, pv);
    }
  }

  public Set<BaseCallMatrix<Definition>> getResult() {
    return myCollectedCalls;
  }

  private static BaseCallMatrix.R isLess(Expression expr1, Expression expr2) {
    if (expr2.toConCall() == null) {
      return expr1.equals(expr2) ? BaseCallMatrix.R.Equal : BaseCallMatrix.R.Unknown;
    }
    if (expr1.toConCall() != null && expr1.toConCall().getDefinition() == expr2.toConCall().getDefinition()) {
      BaseCallMatrix.R ord = isLess(expr1.toConCall().getDefCallArguments(), expr2.toConCall().getDefCallArguments());
      if (ord != BaseCallMatrix.R.Unknown) return ord;
    }
    for (Expression arg : expr2.toConCall().getDefCallArguments()) {
      if (isLess(expr1, arg) != BaseCallMatrix.R.Unknown) return BaseCallMatrix.R.LessThan;
    }
    return BaseCallMatrix.R.Unknown;
  }

  private static BaseCallMatrix.R isLess(List<? extends Expression> exprs1, List<? extends Expression> exprs2) {
    for (int i = 0; i < Math.min(exprs1.size(), exprs2.size()); i++) {
      BaseCallMatrix.R ord = isLess(exprs1.get(i), exprs2.get(i));
      if (ord != BaseCallMatrix.R.Equal) return ord;
    }
    return exprs1.size() >= exprs2.size() ? BaseCallMatrix.R.Equal : BaseCallMatrix.R.Unknown;
  }

  private BaseCallMatrix.R compare(Expression argument, Expression sample) {
    // strip currentExpression of App & Proj calls
    boolean f;
    do {
      f = false;
      if (argument instanceof AppExpression) {
        argument = argument.getFunction();
        f = true;
      }
      if (argument instanceof ProjExpression) {
        argument = ((ProjExpression) argument).getExpression();
        f = true;
      }
      if (argument instanceof FunCallExpression && ((FunCallExpression) argument).getDefinition() == Prelude.AT) {
        argument = ((FunCallExpression) argument).getDefCallArguments().get(3);
        f = true;
      }
    } while (f);

    return isLess(argument, sample);
  }

  private void collectCall(DefCallExpression expression, ParameterVector vector) {
    if (myCycle != null && !myCycle.contains(expression.getDefinition())) return;

    BaseCallMatrix<Definition> cm = new CallMatrix(myDefinition, expression);
    assert (cm.getHeight() == vector.getHeight());
    for (int i = 0; i < vector.getHeight(); i++) {
      for (int j = 0; j < expression.getDefCallArguments().size(); j++) {
        cm.set(i, j, compare(expression.getDefCallArguments().get(j), vector.getParameter(i)));
      }
    }
    myCollectedCalls.add(cm);
  }

  @Override
  public Void visitFunCall(FunCallExpression expression, ParameterVector vector) {
    collectCall(expression, vector);

    for (Expression argument : expression.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitConCall(ConCallExpression expression, ParameterVector vector) {
    // Cycles consisting of constructors are currently unsupported
    /*
    Constructor constructor = expression.getDefinition();
    if (constructor.getDataType().getCondition(constructor) != null) {
      collectCall(expression, vector);
    }
    */
    for (Expression argument : expression.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitApp(AppExpression expression, ParameterVector vector) {
    expression.getFunction().accept(this, vector);

    for (Expression e : expression.getArguments()) {
      e.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitBranch(BranchElimTreeNode node, ParameterVector vector) {
    for (ConstructorClause clause : node.getConstructorClauses()) {
      clause.getChild().accept(this, new ParameterVector(vector, clause));
    }
    return null;
  }

  @Override
  public Void visitLet(LetExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);

    for (LetClause lc : expression.getClauses()) {
      lc.getResultType().getExpr().accept(this, vector);
      for (SingleDependentLink link : lc.getParameters()) {
        visitDependentLink(link, vector);
      }
      lc.getElimTree().accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitLeaf(LeafElimTreeNode node, ParameterVector vector) {
    node.getExpression().accept(this, vector);
    return null;
  }


  @Override
  public Void visitDataCall(DataCallExpression expression, ParameterVector vector) {
    for (Expression e : expression.getDefCallArguments()) {
      e.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitFieldCall(FieldCallExpression expression, ParameterVector vector) {
    for (Expression e : expression.getDefCallArguments()) {
      e.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitClassCall(ClassCallExpression expression, ParameterVector vector) {
    for (Map.Entry<ClassField, FieldSet.Implementation> i : expression.getFieldSet().getImplemented()) {
      i.getValue().term.accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitLetClauseCall(LetClauseCallExpression expr, ParameterVector vector) {
    for (Expression argument : expr.getDefCallArguments()) {
      argument.accept(this, vector);
    }
    return null;
  }

  private Void visitDependentLink(DependentLink link, ParameterVector vector) {
    for (; link.hasNext(); link = link.getNext()) {
      link = link.getNextTyped(null);
      link.getType().getExpr().accept(this, vector);
    }
    return null;
  }

  @Override
  public Void visitLam(LamExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    expression.getBody().accept(this, vector);
    return null;
  }

  @Override
  public Void visitPi(PiExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    expression.getCodomain().accept(this, vector);
    return null;
  }

  @Override
  public Void visitSigma(SigmaExpression expression, ParameterVector vector) {
    visitDependentLink(expression.getParameters(), vector);
    return null;
  }

  @Override
  public Void visitTuple(TupleExpression expression, ParameterVector vector) {
    for (Expression e : expression.getFields()) {
      e.accept(this, vector);
    }

    expression.getType().accept(this, vector);
    return null;
  }

  @Override
  public Void visitProj(ProjExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);
    return null;
  }

  @Override
  public Void visitNew(NewExpression expression, ParameterVector vector) {
    expression.getExpression().accept(this, vector);
    return null;
  }

  @Override
  public Void visitUniverse(UniverseExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitError(ErrorExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitEmpty(EmptyElimTreeNode node, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitReference(ReferenceExpression expression, ParameterVector vector) {
    return null;
  }

  @Override
  public Void visitInferenceReference(InferenceReferenceExpression expression, ParameterVector vector) {
    throw new IllegalStateException();
  }

  @Override
  public Void visitOfType(OfTypeExpression expression, ParameterVector vector) {
    throw new IllegalStateException();
  }

  public static class ParameterVector {
    private Expression[] myParts;

    ParameterVector(FunctionDefinition def) {
      int paramCount = def.getNumberOfRequiredArguments();
      myParts = new Expression[paramCount];

      int i = 0;
      DependentLink dl = def.getParameters();
      while (!(dl instanceof EmptyDependentLink)) {
        myParts[i] = new ReferenceExpression(dl);

        dl = dl.getNext();
        i++;
      }
    }

    ParameterVector(ParameterVector pv, SubstVisitor sv) {
      myParts = new Expression[pv.myParts.length];
      for (int i = 0; i < pv.myParts.length; i++) {
        myParts[i] = pv.myParts[i].accept(sv, null);
      }
    }

    ParameterVector(ParameterVector pv, Clause c) {
      this(pv, new SubstVisitor(c.getSubst(), LevelSubstitution.EMPTY));
    }

    Expression getParameter(int i) {
      return myParts[i];
    }

    int getHeight() {
      return myParts.length;
    }
  }

}
