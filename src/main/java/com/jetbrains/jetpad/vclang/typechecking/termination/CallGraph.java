package com.jetbrains.jetpad.vclang.typechecking.termination;

/*Generated by MPS */

import java.util.*;

import com.jetbrains.jetpad.vclang.term.definition.FunctionDefinition;

public class CallGraph {
    private HashMap<Object, HashMap<Object, HashSet<BaseCallMatrix>>> myGraph = new HashMap<>();
    private int myNewEdges = 0;

    public CallGraph(Set<BaseCallMatrix> set) {
        add(set);
    }

    private CallGraph(CallGraph g) {
        for (Object vDom : g.myGraph.keySet()) {
            HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
            for (Object vCodom : outboundEdges.keySet()) {
                for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
                    append(edge);
                }
            }
        }

        for (Object vDom : g.myGraph.keySet()) {
            HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
            for (Object vCodom : outboundEdges.keySet()) {
                for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
                    HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges2 = g.myGraph.get(edge.getCodomain());
                    if (outboundEdges2 != null) {
                        for (HashSet<BaseCallMatrix> edgesSheaf : outboundEdges2.values()) {
                            for (BaseCallMatrix edge2 : edgesSheaf) {
                                if (append(new CompositeCallMatrix(edge, edge2))) {
                                    myNewEdges++;
                                }
                            }
                        }
                    }
                }
            }
        }


    }

    public void add(FunctionDefinition def) {
        add(new CollectCallVisitor(def).getResult());
    }

    public void add(Set<BaseCallMatrix> set) {
        for (BaseCallMatrix cm : set) {
            append(cm);
        }
    }

    @Override
    public String toString() {
        String result = "";
        for (Object vDom : myGraph.keySet()) {
            for (Object vCodom : myGraph.get(vDom).keySet()) {
                result += vDom + " -> " + vCodom + "\n ";
                for (BaseCallMatrix cm : myGraph.get(vDom).get(vCodom)) {
                    result += cm.toString() + "\n";
                }
            }
        }
        return result;
    }

    private boolean append(BaseCallMatrix cm) {
        HashSet<BaseCallMatrix> set;
        HashMap<Object, HashSet<BaseCallMatrix>> map;
        if (!(myGraph.containsKey(cm.getDomain()))) {
            map = new HashMap<>();
            set = new HashSet<>();
            set.add(cm);
            map.put(cm.getCodomain(), set);
            myGraph.put(cm.getDomain(), map);
            return true;
        } else {
            map = myGraph.get(cm.getDomain());
            if (!(map.containsKey(cm.getCodomain()))) {
                set = new HashSet<>();
                set.add(cm);
                map.put(cm.getCodomain(), set);
                return true;
            } else {
                set = map.get(cm.getCodomain());
                boolean alreadyContainsEqual = false;

                for (BaseCallMatrix c : set) {
                    if (cm.equals(c)) {
                        alreadyContainsEqual = true;
                    }
                }

                if (!(alreadyContainsEqual)) {
                    set.add(cm);
                }

                return !(alreadyContainsEqual);
            }
        }
    }

    private static Set<List<BaseCallMatrix.R>> createShorterBehavior(Set<List<BaseCallMatrix.R>> recBehaviors, int i) {
        Set<List<BaseCallMatrix.R>> result = new HashSet<>();
        for (List<BaseCallMatrix.R> l : recBehaviors) {
            switch (l.get(i)) {
                case LessThan:
                    continue;
                case Equal:
                    List<BaseCallMatrix.R> l2 = new LinkedList<>();
                    l2.addAll(l);
                    l2.remove(i);
                    result.add(l2);
                    continue;
                case Unknown:
                    return null;
            }
        }
        return result;
    }

    private static List<Integer> findTerminationOrder(Set<List<BaseCallMatrix.R>> recBehaviors, List<Integer> indices) {
        if (recBehaviors == null) throw new IllegalArgumentException();
        if (recBehaviors.isEmpty()) return indices;

        int l = recBehaviors.iterator().next().size();

        for (int i = 0; i < l; i++) {
            Set<List<BaseCallMatrix.R>> shorterBehavior = createShorterBehavior(recBehaviors, i);
            if (shorterBehavior != null) {
                List<Integer> shorterIndices = new LinkedList<>();
                shorterIndices.addAll(indices);
                shorterIndices.remove(i);
                List<Integer> termOrder = findTerminationOrder(shorterBehavior, shorterIndices);
                if (termOrder != null) {
                    termOrder.add(0, indices.get(i));
                    return termOrder;
                }
            }
        }

        return null;
    }

    public boolean checkTermination() {
        // extract recursive behaviors
        HashMap<Object, Set<List<BaseCallMatrix.R>>> recursiveBehaviors = new HashMap<>();
        for (Object v : myGraph.keySet()) {
            Set<BaseCallMatrix> endomorphisms = myGraph.get(v).get(v);
            if (endomorphisms != null && !endomorphisms.isEmpty()) {
                Set<List<BaseCallMatrix.R>> behaviors = new HashSet<>();
                recursiveBehaviors.put(v, behaviors);
                for (BaseCallMatrix callMatrix : endomorphisms) {
                    List<BaseCallMatrix.R> recursiveBehavior = new LinkedList<>();
                    for (int i = 0; i < callMatrix.getHeight(); i++) recursiveBehavior.add(callMatrix.getValue(i, i));
                    behaviors.add(recursiveBehavior);
                }
            }
        }

        boolean result = true;

        for (Object v : recursiveBehaviors.keySet()) {
            Set<List<BaseCallMatrix.R>> behaviors = recursiveBehaviors.get(v);
            if (!behaviors.isEmpty()) {
                int len = behaviors.iterator().next().size();
                List<Integer> indices = new LinkedList<>();
                for (int i = 0; i < len; i++) indices.add(i + 1);
                List<Integer> terminationOrder = findTerminationOrder(behaviors, indices);
                if (terminationOrder == null) {
                    result = false;
                }
            }
        }

        return result;
    }

    public static CallGraph calculateClosure(CallGraph cg) {
        do {
            cg = new CallGraph(cg);
        } while (cg.myNewEdges != 0);

        return cg;
    }


}
