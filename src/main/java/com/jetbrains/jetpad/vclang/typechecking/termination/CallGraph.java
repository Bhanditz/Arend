package com.jetbrains.jetpad.vclang.typechecking.termination;

/*Generated by MPS */

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import com.jetbrains.jetpad.vclang.term.definition.FunctionDefinition;

public class CallGraph {
  private HashMap<Object, HashMap<Object, HashSet<BaseCallMatrix>>> myGraph = new HashMap<>();
  private int myNewEdges = 0;


  public CallGraph(Set<BaseCallMatrix> set) {
    add(set);
  }

  public CallGraph(CallGraph g) {
    for (Object vDom : g.myGraph.keySet()) {
      HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
      for (Object vCodom : outboundEdges.keySet()) {
        for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
          append(edge);
        }
      }
    }

    for (Object vDom : g.myGraph.keySet()) {
      HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
      for (Object vCodom : outboundEdges.keySet()) {
        for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
          HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges2 = g.myGraph.get(edge.getCodomain());
          if (outboundEdges2 != null) {
            for (HashSet<BaseCallMatrix> edgesSheaf : outboundEdges2.values()) {
              for (BaseCallMatrix edge2 : edgesSheaf) {
                if (append(new CompositeCallMatrix(edge, edge2))) {
                  myNewEdges++;
                }
              }
            }
          }
        }
      }
    }


  }

  public void add(FunctionDefinition def) {
    add(new CollectCallVisitor(def).getResult());
  }

  public void add(Set<BaseCallMatrix> set) {
    for (BaseCallMatrix cm : set) {
      append(cm);
    }
  }

  @Override
  public String toString() {
    String result = "";
    for (Object vDom : myGraph.keySet()) {
      for (Object vCodom : myGraph.get(vDom).keySet()) {
        result += vDom + " -> " + vCodom + "\n ";
        for (BaseCallMatrix cm : myGraph.get(vDom).get(vCodom)) {
          result += cm.toString() + "\n";
        }
      }
    }
    return result;
  }


  private boolean append(BaseCallMatrix cm) {
    HashSet<BaseCallMatrix> set;
    HashMap<Object, HashSet<BaseCallMatrix>> map;
    if (!(myGraph.containsKey(cm.getDomain()))) {
      map = new HashMap<>();
      set = new HashSet<>();
      set.add(cm);
      map.put(cm.getCodomain(), set);
      myGraph.put(cm.getDomain(), map);
      return true;
    } else {
      map = myGraph.get(cm.getDomain());
      if (!(map.containsKey(cm.getCodomain()))) {
        set = new HashSet<>();
        set.add(cm);
        map.put(cm.getCodomain(), set);
        return true;
      } else {
        set = map.get(cm.getCodomain());
        boolean alreadyContainsEqual = false;

        for (BaseCallMatrix c : set) {
          if (cm.equals(c)) {
            alreadyContainsEqual = true;
          }
        }

        if (!(alreadyContainsEqual)) {
          set.add(cm);
        }

        return !(alreadyContainsEqual);
      }
    }
  }

  public static CallGraph calculateClosure(CallGraph cg) {
    do {
      cg = new CallGraph(cg);
    } while (cg.myNewEdges != 0);

    return cg;
  }

}
