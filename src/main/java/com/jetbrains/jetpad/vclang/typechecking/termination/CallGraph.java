package com.jetbrains.jetpad.vclang.typechecking.termination;

/*Generated by MPS */

import java.util.*;

import com.jetbrains.jetpad.vclang.term.definition.FunctionDefinition;

public class CallGraph {
    private HashMap<Object, HashMap<Object, HashSet<BaseCallMatrix>>> myGraph = new HashMap<>();
    private int myNewEdges = 0;
    private boolean isCompositionClosed = false;

    public CallGraph(Set<BaseCallMatrix> set) {
        add(set);
    }

    private CallGraph(CallGraph g) {
        for (Object vDom : g.myGraph.keySet()) {
            HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
            for (Object vCodom : outboundEdges.keySet()) {
                for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
                    append(edge);
                }
            }
        }

        for (Object vDom : g.myGraph.keySet()) {
            HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges = g.myGraph.get(vDom);
            for (Object vCodom : outboundEdges.keySet()) {
                for (BaseCallMatrix edge : outboundEdges.get(vCodom)) {
                    HashMap<Object, HashSet<BaseCallMatrix>> outboundEdges2 = g.myGraph.get(edge.getCodomain());
                    if (outboundEdges2 != null) {
                        for (HashSet<BaseCallMatrix> edgesSheaf : outboundEdges2.values()) {
                            for (BaseCallMatrix edge2 : edgesSheaf) {
                                if (append(new CompositeCallMatrix(edge, edge2))) {
                                    myNewEdges++;
                                }
                            }
                        }
                    }
                }
            }
        }


    }

    public void add(FunctionDefinition def) {
        add(new CollectCallVisitor(def).getResult());
    }

    public void add(Set<BaseCallMatrix> set) {
        for (BaseCallMatrix cm : set) {
            append(cm);
        }
    }

    @Override
    public String toString() {
        String result = "";
        for (Object vDom : myGraph.keySet()) {
            for (Object vCodom : myGraph.get(vDom).keySet()) {
                result += vDom + " -> " + vCodom + "\n ";
                for (BaseCallMatrix cm : myGraph.get(vDom).get(vCodom)) {
                    result += cm.toString() + "\n";
                }
            }
        }
        return result;
    }

    private boolean append(BaseCallMatrix cm) {
        HashSet<BaseCallMatrix> set;
        HashMap<Object, HashSet<BaseCallMatrix>> map;
        if (!(myGraph.containsKey(cm.getDomain()))) {
            map = new HashMap<>();
            set = new HashSet<>();
            set.add(cm);
            map.put(cm.getCodomain(), set);
            myGraph.put(cm.getDomain(), map);
            return true;
        } else {
            map = myGraph.get(cm.getDomain());
            if (!(map.containsKey(cm.getCodomain()))) {
                set = new HashSet<>();
                set.add(cm);
                map.put(cm.getCodomain(), set);
                return true;
            } else {
                set = map.get(cm.getCodomain());
                boolean alreadyContainsEqual = false;

                for (BaseCallMatrix c : set) {
                    if (cm.equals(c)) {
                        alreadyContainsEqual = true;
                    }
                }

                if (!(alreadyContainsEqual)) {
                    set.add(cm);
                }

                return !alreadyContainsEqual;
            }
        }
    }

    public static CallGraph calculateClosure(CallGraph cg) {
        do {
            cg = new CallGraph(cg);
        } while (cg.myNewEdges != 0);

        cg.isCompositionClosed = true;

        return cg;
    }

    public boolean checkTermination() {
        boolean result = true;
        for (Object v : myGraph.keySet()) {
            RecursiveBehaviors rbs = new RecursiveBehaviors(this, v);
            List<String> order = rbs.findTerminationOrderAnnotated();
            if (order == null) {
                result = false;
                System.out.println("\nUnable to find termination order for " + v);
                System.out.println("The problem is with the following recursive call(s): ");
                for (RecursiveBehaviors.RecursiveBehavior rb : rbs.myBestRbAttained.onlyMinimalElements()) {
                    System.out.println(rb);
                }
            } else {
                System.out.println("\nFound termination order for " + v);
                System.out.println(order);
            }
        }
        return result;
    }

    public static class RecursiveBehaviors {
        private Object myBasepoint = null;
        private Set<RecursiveBehavior> myBehaviors = new HashSet<>();
        private int myLength = -1;
        private RecursiveBehaviors myBestRbAttained = null;

        public RecursiveBehaviors(CallGraph graph, Object v) {
            this(graph.myGraph.get(v).get(v));
            if (!graph.isCompositionClosed) throw new IllegalArgumentException();
            myBasepoint = v;
        }

        public RecursiveBehaviors(Set<BaseCallMatrix> callMatrices) {
            for (BaseCallMatrix m : callMatrices) myBehaviors.add(new RecursiveBehavior(m));
            if (!myBehaviors.isEmpty()) {
                Iterator<RecursiveBehavior> i = myBehaviors.iterator();
                myLength = i.next().getLength();
                while (i.hasNext()) if (myLength != i.next().getLength()) throw new IllegalArgumentException();

            }
        }

        private RecursiveBehaviors() {
        }


        public RecursiveBehaviors createShorterBehavior(int i) {
            RecursiveBehaviors result = new RecursiveBehaviors();
            for (RecursiveBehavior rb : myBehaviors) {
                switch (rb.myBehavior.get(i)) {
                    case LessThan:
                        continue;
                    case Equal:
                        result.myBehaviors.add(new RecursiveBehavior(rb, i));
                        continue;
                    case Unknown:
                        return null;
                }
            }
            result.myLength = myLength - 1;
            result.myBasepoint = myBasepoint;
            return result;
        }

        private List<Integer> findTerminationOrder(RecursiveBehaviors recBehaviors, List<Integer> indices) {
            if (recBehaviors == null) throw new IllegalArgumentException();

            if (recBehaviors.myBehaviors.isEmpty()) return indices;
            if (recBehaviors.myLength == 0) return null;

            if (myBestRbAttained == null || myBestRbAttained.myLength > recBehaviors.myLength)
                myBestRbAttained = recBehaviors;

            for (int i = 0; i < recBehaviors.myLength; i++) {
                RecursiveBehaviors shorterBehavior = recBehaviors.createShorterBehavior(i);
                if (shorterBehavior != null) {
                    List<Integer> shorterIndices = new LinkedList<>(indices);
                    shorterIndices.remove(i);
                    List<Integer> termOrder = findTerminationOrder(shorterBehavior, shorterIndices);
                    if (termOrder != null) {
                        termOrder.add(0, indices.get(i));
                        return termOrder;
                    }
                }
            }

            return null;
        }

        public List<Integer> findTerminationOrder() {
            List<Integer> indices = new LinkedList<>();
            for (int i = 0; i < myLength; i++) indices.add(i);
            return findTerminationOrder(this, indices);
        }

        public List<String> findTerminationOrderAnnotated() {
            List<Integer> to = findTerminationOrder();
            if (to == null) return null;
            if (myBehaviors.isEmpty()) throw new IllegalStateException();
            RecursiveBehavior rb = myBehaviors.iterator().next();
            List<String> result = new ArrayList<>();
            for (Integer i : to) result.add(rb.myLabels.get(i));

            return result;
        }

        public Set<RecursiveBehavior> onlyMinimalElements() {
            Set<RecursiveBehavior> result = new HashSet<>();
            for (RecursiveBehavior rb : myBehaviors) {
                boolean containsSmaller = false;
                Set<RecursiveBehavior> greater = new HashSet<>();
                for (RecursiveBehavior rb2 : result) if (rb2.leq(rb)) {
                    containsSmaller = true;
                    break;
                } else if (rb.leq(rb2) && !rb.equals(rb2)) {
                    greater.add(rb2);
                }
                result.removeAll(greater);
                if (!containsSmaller) result.add(rb);
            }
            return result;
        }

        private static class RecursiveBehavior {
            List<BaseCallMatrix.R> myBehavior;
            List<String> myLabels;
            BaseCallMatrix myInitialCallMatrix;

            private RecursiveBehavior(BaseCallMatrix callMatrix) {
                myBehavior = new LinkedList<>();
                for (int i = 0; i < callMatrix.getHeight(); i++) myBehavior.add(callMatrix.getValue(i, i));
                myLabels = new LinkedList<>(Arrays.asList(callMatrix.getRowLabels()));
                if (myLabels.size() != myBehavior.size()) throw new IllegalArgumentException();
                myInitialCallMatrix = callMatrix;
            }

            public RecursiveBehavior(RecursiveBehavior rb, int i) {
                if (i < 0 || i >= rb.getLength()) throw new IllegalArgumentException();
                myBehavior = new LinkedList<>(rb.myBehavior);
                myLabels = new LinkedList<>(rb.myLabels);
                myBehavior.remove(i);
                myLabels.remove(i);
                myInitialCallMatrix = rb.myInitialCallMatrix;
            }

            int getLength() {
                return myBehavior.size();
            }

            @Override
            public boolean equals(Object o) {
                if (o instanceof RecursiveBehavior) {
                    RecursiveBehavior rb2 = (RecursiveBehavior) o;
                    return myBehavior.equals(rb2.myBehavior) && myLabels.equals(rb2.myLabels);
                }
                return false;
            }

            boolean leq (RecursiveBehavior r) {
                if (getLength() != r.getLength()) throw new IllegalArgumentException();
                boolean result = true;
                for (int i = 0; i < getLength(); i++) if (!CallMatrix.rleq(myBehavior.get(i), r.myBehavior.get(i))) return false;
                return true;
            }

            @Override
            public String toString() {
                String result = myInitialCallMatrix.getMatrixLabel() + "\n";
                String valueLine = "";
                for (int i = 0; i < getLength(); i++) {
                    String label = myLabels.get(i);
                    CallMatrix.R r = myBehavior.get(i);
                    valueLine += String.format("%" + (label.length() + 1) + "s", CallMatrix.rToChar(r));
                    result += " " + label;
                }
                return result + "\n" + valueLine;
            }
        }

    }

}
