{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Arend (aka vclang) is a theorem prover based on Homotopy Type Theory . For the installation instructions, see this section . The section Language Reference contains a description of the Arend language. For a tutorial, see this section .","title":"Overview"},{"location":"getting-started/","text":"Getting Started You need to have JRE 8 installed on your computer to use Arend. Arend is available either as an IntelliJ IDEA plugin (see this section for the installation instructions) or as a console applications (see this section for the installation instructions). IntelliJ IDEA Plugin To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-vclang.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Vclang in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file project_name .vcl and an empty directory src . The vcl file contains a description of the project. Create a new file example.vc in src directory. Add the following line to this file: \\func f = 0 Right click example.vc file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.vc:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference . Console Application To install the console application, follow the instructions below. Download the vclang jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar vclang.jar to check that everything is alright. You should see the following output: $ java -jar vclang.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar vclang.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file myProject.vcl inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to myProject.vcl : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.vc inside src with the following content: \\func f = 0 Run java -jar $vclang $myProject , where $vclang is the path to vclang.jar and $myProject is the path to myProject.vcl . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.vc as follows: \\func f : Nat - Nat = 0 If you run java -jar $vclang $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Getting Started"},{"location":"getting-started/#intellij-idea-plugin","text":"To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-vclang.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Vclang in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file project_name .vcl and an empty directory src . The vcl file contains a description of the project. Create a new file example.vc in src directory. Add the following line to this file: \\func f = 0 Right click example.vc file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.vc:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference .","title":"IntelliJ IDEA Plugin"},{"location":"getting-started/#console-application","text":"To install the console application, follow the instructions below. Download the vclang jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar vclang.jar to check that everything is alright. You should see the following output: $ java -jar vclang.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar vclang.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file myProject.vcl inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to myProject.vcl : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.vc inside src with the following content: \\func f = 0 Run java -jar $vclang $myProject , where $vclang is the path to vclang.jar and $myProject is the path to myProject.vcl . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.vc as follows: \\func f : Nat - Nat = 0 If you run java -jar $vclang $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Console Application"},{"location":"language-reference/","text":"Language Reference Lexical Structure Definitions Modules Parameters Function Definitions Data Definitions Higher inductive types Records Classes Instances Coercion Expressions Goals Universes Let Case Pi types Sigma types Class extensions","title":"Table of Contents"},{"location":"language-reference/definitions/","text":"Definitions Arend has the following definitions: functions , data , records , classes , instances , and coercions . Every definition has a name which must be a valid identifier as described here . Definitions can be referred by their names. If we defined a definition named def , then we can write the following expression: def e_1 ... e_n , where e_1 , ..., e_n are expressions. Such an expression is called defcall . Expressions e_1 , ..., e_n are called arguments of this defcall. If we have only two parameters, we can write a defcall in the infix notation: e_1 `def` e_2 . This expression is equivalent to def e_1 e_2 . If we have only one parameter, we can use the postfix notation: e_1 `def . This expression is equivalent to def e_1 . Precedence To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 . Infix operators A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Definitions"},{"location":"language-reference/definitions/#precedence","text":"To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 .","title":"Precedence"},{"location":"language-reference/definitions/#infix-operators","text":"A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Infix operators"},{"location":"language-reference/expressions/","text":"Expressions An expression denotes a value which may depend on some variables. The basic example of an expression is simply a variable x . Of course, x must be defined somewhere in order for such an expression to make sense. It can be either a parameter (of a definition , or a lambda expression , or a pi expression , or a sigma expression ), a variable define in a let expression , or a variable defined in a pattern . If e , e_1 , ... e_n are expressions and x_1 , ... x_n are variables, then we will write e[e_1/x_1, ... e_n/x_n] for the substitution operation. This is a meta-operation, that is it is a function on the set of expressions of the language and not an expression itself. The expression e[e_1/x_1, ... e_n/x_n] is simply e in which every occurrence of each of the variables x_i is replaced with the expression e_i . Evaluation There is a binary relation = on the set of expressions called the reduction relation . If e_1 = ... = e_n , we will say that e_1 reduces to e_n . If there is no e' such that e = e' , we will say that e is a normal form . If e reduces to e' and e' is a normal form, we will say that e' is a normal form of e and that e evaluates to e' . Every expression has a unique normal form. The relation = is a meta-relation on the set of expressions of the language, that is you cannot refer to it explicitly in the language. This relation is used by the typechecker to compare expressions. The typechecker never compares expressions directly. To compare expressions e_1 and e_2 , it first evaluates their normal forms and then compares them. Since normal forms always exist, the comparison algorithm always terminates, but it is easy to write an expression that does not evaluate in any reasonable time. Types Every expression has a type. A type is an expression which has type \\Type . The expression \\Type is discussed in this section . Every variable has a type which is specified when the variable is defined (or can be inferred). An expression of the form x has the type of the variable x . The type of an expression usually can be inferred automatically, but sometimes it is useful to specify it explicitly. An expression of the form (e : E) (parentheses are necessary) is equivalent to e , but also has an explicit type annotation. In this expression, e must have type E and the type of the whole expression is also E (since it is equivalent to e ). Defcalls A defcall is an expression of the form f a_1 ... a_n , where f is a definition with n parameters (an exception is classes and records in which case only expressions without arguments are called defcalls, see this section for the discussion of such expressions). If f is a definition with parameters x_1 , ... x_n and the result type R , then the type of a defcall f a_1 ... a_n is R[a_1/x_1, ... a_n/x_n] . If f is either a class, a record, a data type, a constructor without conditions, an instance, or a function defined by copattern matching, then f a_1 ... a_n is a normal form whenever a_1 , ... a_n are. If f is a function defined as \\func f (x_1 : A_1) ... (x_n : A_n) = e , then f a_1 ... a_n reduces to e[a_1/x_1, ... a_n/x_n] . If f is a function defined by pattern matching or a constructor with conditions, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f is an instance or a function defined by copattern matching, then the evaluation of defcalls f a_1 ... a_n is described in this section .","title":"Expressions"},{"location":"language-reference/expressions/#evaluation","text":"There is a binary relation = on the set of expressions called the reduction relation . If e_1 = ... = e_n , we will say that e_1 reduces to e_n . If there is no e' such that e = e' , we will say that e is a normal form . If e reduces to e' and e' is a normal form, we will say that e' is a normal form of e and that e evaluates to e' . Every expression has a unique normal form. The relation = is a meta-relation on the set of expressions of the language, that is you cannot refer to it explicitly in the language. This relation is used by the typechecker to compare expressions. The typechecker never compares expressions directly. To compare expressions e_1 and e_2 , it first evaluates their normal forms and then compares them. Since normal forms always exist, the comparison algorithm always terminates, but it is easy to write an expression that does not evaluate in any reasonable time.","title":"Evaluation"},{"location":"language-reference/expressions/#types","text":"Every expression has a type. A type is an expression which has type \\Type . The expression \\Type is discussed in this section . Every variable has a type which is specified when the variable is defined (or can be inferred). An expression of the form x has the type of the variable x . The type of an expression usually can be inferred automatically, but sometimes it is useful to specify it explicitly. An expression of the form (e : E) (parentheses are necessary) is equivalent to e , but also has an explicit type annotation. In this expression, e must have type E and the type of the whole expression is also E (since it is equivalent to e ).","title":"Types"},{"location":"language-reference/expressions/#defcalls","text":"A defcall is an expression of the form f a_1 ... a_n , where f is a definition with n parameters (an exception is classes and records in which case only expressions without arguments are called defcalls, see this section for the discussion of such expressions). If f is a definition with parameters x_1 , ... x_n and the result type R , then the type of a defcall f a_1 ... a_n is R[a_1/x_1, ... a_n/x_n] . If f is either a class, a record, a data type, a constructor without conditions, an instance, or a function defined by copattern matching, then f a_1 ... a_n is a normal form whenever a_1 , ... a_n are. If f is a function defined as \\func f (x_1 : A_1) ... (x_n : A_n) = e , then f a_1 ... a_n reduces to e[a_1/x_1, ... a_n/x_n] . If f is a function defined by pattern matching or a constructor with conditions, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f is an instance or a function defined by copattern matching, then the evaluation of defcalls f a_1 ... a_n is described in this section .","title":"Defcalls"},{"location":"language-reference/lexical-structure/","text":"Lexical Structure Keywords All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type . Numerals A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers. Identifiers An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - . Infix and postfix notation A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section . Comments Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Lexical Structure"},{"location":"language-reference/lexical-structure/#keywords","text":"All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type .","title":"Keywords"},{"location":"language-reference/lexical-structure/#numerals","text":"A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers.","title":"Numerals"},{"location":"language-reference/lexical-structure/#identifiers","text":"An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - .","title":"Identifiers"},{"location":"language-reference/lexical-structure/#infix-and-postfix-notation","text":"A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section .","title":"Infix and postfix notation"},{"location":"language-reference/lexical-structure/#comments","text":"Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Comments"},{"location":"language-reference/definitions/classes/","text":"Classes TODO","title":"Classes"},{"location":"language-reference/definitions/coercion/","text":"Coercion TODO","title":"Coercion"},{"location":"language-reference/definitions/data/","text":"Data Definitions TODO","title":"Data Definitions"},{"location":"language-reference/definitions/functions/","text":"Functions Definitions Functions in Arend are functions in the mathematical sense. They can have arbitrary arity. In particular, constants in Arend are just functions of arity 0. A definition of a function consists of its name, a signature which consists of a list of parameters and (possibly) a result type, and a body which is an expression that describes the behaviour of the function. Non-recursive functions To define a non-recursive function, write \\func f p_1 ... p_n = e , where f is the name of the function, p_1 , ... p_n are named parameters , and e is an expression which denotes the result of the function. You can also specify the result type of the function by writing \\func f p_1 ... p_n : T = e , where T is an expression which denotes the result type. In this case, e must have type T . Often the typechecker can infer the result type, so usually you don't have to specify it explicitly. For example, to define the identity function on type A , write the following code: \\func id (x : A) = x A function with three parameters that returns the second one can be defined as follows: \\func second (x : A) (y : B) (z : C) = y You can explicitly specify the result types of these functions. The definitions above are equivalent to the following definitions: \\func id (x : A) : A = x \\func second (x : A) (y : B) (z : C) : B = y Parameters of a function may appear in its body and in its result type. Pattern matching Functions can be defined by recursion. If D is a data type with constructors con1 and con2 Nat . Then you can define a function which maps D to natural numbers in such a way that con1 is mapped to 0 and con2 n is mapped to suc n : \\func f (d : D) : Nat | con1 = 0 | con2 n = suc n The result type of a recursive function must be specified explicitly. The general form of a recursive function is \\func f (x_1 : T_1) ... (x_n : T_n) : R | p^1_1, ... p^1_n = e_1 ... | p^k_1, ... p^k_n = e_k where p^i_j is a pattern of type T_i and e_i is an expression of type R[p^i_1/x_1, ... p^i_n/x_n] (see this section for the discussion of the substitution operation and types of expressions). Note that variables x_1 , ... x_n are not visible in expressions e_i . If a pattern p^i_j contains a variable x as a subpattern of type T , then this variable may appear in expression e_i and it will have the type T . If some of the parameters of f are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . A pattern of type T can have one of the following forms: A variable. If this variable is not used anywhere, its name can be replaces with _ . con s_1 ... s_m , where con (y_1 : A_1) ... (y_m : A_m) is a constructor of a data type D and s_1 ... s_m are patterns. In this case, T must be equal to D and pattern s_i must have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If some of the parameters of con are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . (s_1, ... s_m) , where s_1 ... s_m are patterns. In this case, T must be either a Sigma type with parameters (y_1 : A_1) ... (y_m : A_m) or a class (or a record ) with fields y_1 : A_1 , ... y_m : A_m . The pattern s_i will have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If m equals to 0, then T also may be a data type without constructors. In this case, the right hand side = e_i of the clause in which such a pattern appears must be omitted. Now, let us discuss how expressions of the form f a_1 ... a_n evaluate (see this section for the definition of the reduction and evaluation relations). To reduce an expression E = f a_1 ... a_n , we first evaluate expressions a_1 , ... a_n and match them with the patterns in the definition of f top to bottom, left to right. If all patterns p^i_1 , ... p^i_n matches with a_1 , ... a_n for some i, then E reduces to e_i[b_1/y_1, ... b_k/y_k] , where y_1 , ... y_k are variables that appear in p^i_1 , ... p^i_n and b_1 , ... b_k are subexpressions of a_1 , ... a_n corresponding to these variables. If some argument cannot be matched with a pattern con s_1 ... s_m because it is of the form con' ... for some constructor con' different from con , then the evaluator skips the clause with this patterns and tries the next one. If some argument cannot be matched with a pattern because it is not a constructor, then E does not reduce. If none of the clauses match with arguments, then E also does not reduce. Variables and patterns of the form (s_1, ... s_m) match with any expression. Let us consider an example. Let B be a data type with two constructors T and F . Consider the following function: \\func g (b b' : B) : Nat | T, _ = 0 | _, T = 1 | _, _ = 2 Let x be a variable and let e be an arbitrary expression. If the first argument of g a_1 a_2 is T , then the expression reduces to 0 , if it is x , then expression does not reduce since the first pattern fails to match with x . If the first argument is F , then the evaluator tries to match the second argument: g T e = 0 g x e -- does not reduce g F T = 1 g F F = 2 g F x -- does not reduce You can also write \\func f p_1 ... p_n : R \\with { | c_1 ... | c_n } . The keyword \\with and curly braces are optional and do not affect the defined function. Elim It is often true that we only need to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters. Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient. In this case, we can use the \\elim construction: \\func f (x_1 : A_1) ... (x_n : A_n) : R \\elim x_{i_1}, ... x_{i_m} | p^1_1, ... p^1_m = e_1 ... | p^k_1, ... p^k_m = e_k where i_1, ... i_m are integers such that 1 \u2264 i_1 ... i_m \u2264 n. In this case, parameters x_{i_1} , ... x_{i_m} are eliminated and are not visible in expressions e_1 , ... e_k . Other parameters of f are still visible in these expressions. Note that it does not matter whether a parameter x_i is explicit or implicit when it is eliminated; the corresponding pattern is always explicit. As an example, consider the following function which chooses one of its arguments depending on the value of its other argument: \\func if (b : B) (t e : X) : X \\elim b | T = t | F = e Recursive functions Functions defined by pattern matching can be recursive. That is, if f is a function as described above, then a reference to f may occur inside expressions e_1 , ... e_k . Every function in Arend is a total function. Thus, not every recursive definition is allowed. In order for such a definition to be valid, the recursion must be structural . This roughly means that the arguments to recursive calls of f must be subexpressions of the arguments to the function itself. Function may also be mutually recursive. That is, we can have several functions which refer to each other. In this case, there must be a linear order on the set of these functions f_1 , ... f_n such that the signature of f_i refers only to previous functions. The bodies of the functions may refer to each other as long as the whole recursive system is structural. Copattern matching If the result type of a function is a record or a class, then a function can also be define by copattern matching which has the following syntax: \\func f (x_1 : A_1) ... (x_n : A_n) : C \\cowith | c_1 ... | c_k where c_1 , ... c_k are coclauses . See this section for a definition of coclauses. Such a function has the same semantics as a definition of an instance as described there. It also can be equivalently written as follows: \\func f (x_1 : A_1) ... (x_n : A_n) = \\new C { | c_1 ... | c_k } See this section for the description of the involved constructions.","title":"Function Definitions"},{"location":"language-reference/definitions/functions/#non-recursive-functions","text":"To define a non-recursive function, write \\func f p_1 ... p_n = e , where f is the name of the function, p_1 , ... p_n are named parameters , and e is an expression which denotes the result of the function. You can also specify the result type of the function by writing \\func f p_1 ... p_n : T = e , where T is an expression which denotes the result type. In this case, e must have type T . Often the typechecker can infer the result type, so usually you don't have to specify it explicitly. For example, to define the identity function on type A , write the following code: \\func id (x : A) = x A function with three parameters that returns the second one can be defined as follows: \\func second (x : A) (y : B) (z : C) = y You can explicitly specify the result types of these functions. The definitions above are equivalent to the following definitions: \\func id (x : A) : A = x \\func second (x : A) (y : B) (z : C) : B = y Parameters of a function may appear in its body and in its result type.","title":"Non-recursive functions"},{"location":"language-reference/definitions/functions/#pattern-matching","text":"Functions can be defined by recursion. If D is a data type with constructors con1 and con2 Nat . Then you can define a function which maps D to natural numbers in such a way that con1 is mapped to 0 and con2 n is mapped to suc n : \\func f (d : D) : Nat | con1 = 0 | con2 n = suc n The result type of a recursive function must be specified explicitly. The general form of a recursive function is \\func f (x_1 : T_1) ... (x_n : T_n) : R | p^1_1, ... p^1_n = e_1 ... | p^k_1, ... p^k_n = e_k where p^i_j is a pattern of type T_i and e_i is an expression of type R[p^i_1/x_1, ... p^i_n/x_n] (see this section for the discussion of the substitution operation and types of expressions). Note that variables x_1 , ... x_n are not visible in expressions e_i . If a pattern p^i_j contains a variable x as a subpattern of type T , then this variable may appear in expression e_i and it will have the type T . If some of the parameters of f are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . A pattern of type T can have one of the following forms: A variable. If this variable is not used anywhere, its name can be replaces with _ . con s_1 ... s_m , where con (y_1 : A_1) ... (y_m : A_m) is a constructor of a data type D and s_1 ... s_m are patterns. In this case, T must be equal to D and pattern s_i must have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If some of the parameters of con are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . (s_1, ... s_m) , where s_1 ... s_m are patterns. In this case, T must be either a Sigma type with parameters (y_1 : A_1) ... (y_m : A_m) or a class (or a record ) with fields y_1 : A_1 , ... y_m : A_m . The pattern s_i will have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If m equals to 0, then T also may be a data type without constructors. In this case, the right hand side = e_i of the clause in which such a pattern appears must be omitted. Now, let us discuss how expressions of the form f a_1 ... a_n evaluate (see this section for the definition of the reduction and evaluation relations). To reduce an expression E = f a_1 ... a_n , we first evaluate expressions a_1 , ... a_n and match them with the patterns in the definition of f top to bottom, left to right. If all patterns p^i_1 , ... p^i_n matches with a_1 , ... a_n for some i, then E reduces to e_i[b_1/y_1, ... b_k/y_k] , where y_1 , ... y_k are variables that appear in p^i_1 , ... p^i_n and b_1 , ... b_k are subexpressions of a_1 , ... a_n corresponding to these variables. If some argument cannot be matched with a pattern con s_1 ... s_m because it is of the form con' ... for some constructor con' different from con , then the evaluator skips the clause with this patterns and tries the next one. If some argument cannot be matched with a pattern because it is not a constructor, then E does not reduce. If none of the clauses match with arguments, then E also does not reduce. Variables and patterns of the form (s_1, ... s_m) match with any expression. Let us consider an example. Let B be a data type with two constructors T and F . Consider the following function: \\func g (b b' : B) : Nat | T, _ = 0 | _, T = 1 | _, _ = 2 Let x be a variable and let e be an arbitrary expression. If the first argument of g a_1 a_2 is T , then the expression reduces to 0 , if it is x , then expression does not reduce since the first pattern fails to match with x . If the first argument is F , then the evaluator tries to match the second argument: g T e = 0 g x e -- does not reduce g F T = 1 g F F = 2 g F x -- does not reduce You can also write \\func f p_1 ... p_n : R \\with { | c_1 ... | c_n } . The keyword \\with and curly braces are optional and do not affect the defined function.","title":"Pattern matching"},{"location":"language-reference/definitions/functions/#elim","text":"It is often true that we only need to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters. Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient. In this case, we can use the \\elim construction: \\func f (x_1 : A_1) ... (x_n : A_n) : R \\elim x_{i_1}, ... x_{i_m} | p^1_1, ... p^1_m = e_1 ... | p^k_1, ... p^k_m = e_k where i_1, ... i_m are integers such that 1 \u2264 i_1 ... i_m \u2264 n. In this case, parameters x_{i_1} , ... x_{i_m} are eliminated and are not visible in expressions e_1 , ... e_k . Other parameters of f are still visible in these expressions. Note that it does not matter whether a parameter x_i is explicit or implicit when it is eliminated; the corresponding pattern is always explicit. As an example, consider the following function which chooses one of its arguments depending on the value of its other argument: \\func if (b : B) (t e : X) : X \\elim b | T = t | F = e","title":"Elim"},{"location":"language-reference/definitions/functions/#recursive-functions","text":"Functions defined by pattern matching can be recursive. That is, if f is a function as described above, then a reference to f may occur inside expressions e_1 , ... e_k . Every function in Arend is a total function. Thus, not every recursive definition is allowed. In order for such a definition to be valid, the recursion must be structural . This roughly means that the arguments to recursive calls of f must be subexpressions of the arguments to the function itself. Function may also be mutually recursive. That is, we can have several functions which refer to each other. In this case, there must be a linear order on the set of these functions f_1 , ... f_n such that the signature of f_i refers only to previous functions. The bodies of the functions may refer to each other as long as the whole recursive system is structural.","title":"Recursive functions"},{"location":"language-reference/definitions/functions/#copattern-matching","text":"If the result type of a function is a record or a class, then a function can also be define by copattern matching which has the following syntax: \\func f (x_1 : A_1) ... (x_n : A_n) : C \\cowith | c_1 ... | c_k where c_1 , ... c_k are coclauses . See this section for a definition of coclauses. Such a function has the same semantics as a definition of an instance as described there. It also can be equivalently written as follows: \\func f (x_1 : A_1) ... (x_n : A_n) = \\new C { | c_1 ... | c_k } See this section for the description of the involved constructions.","title":"Copattern matching"},{"location":"language-reference/definitions/hits/","text":"Higher Inductive Types TODO","title":"Higher Inductive Types"},{"location":"language-reference/definitions/instances/","text":"Instances TODO","title":"Instances"},{"location":"language-reference/definitions/modules/","text":"Modules Every definition defined in a file is visible anywhere in this file. That is, the order of definitions does not matter. The module system allows you to define definitions in other namespaces. Modules A module consists of a name and a list of definitions: \\module Mod \\where { def_1 ... def_n } You can refer to definitions def_1 ... def_n inside module Mod by their names. To refer to them outside this module, you need to use their full names Mod.def_1 ... Mod.def_n . For example, consider the following code: \\func f2 = Mod.f1 \\module Mod \\where { \\func f1 = f2 \\func f2 = 0 \\func f3 = f4 } \\func f4 = f2 You cannot refer to f1 in f2 without Mod. prefix. Function f4 refers to f2 defined on the top level. Function Mod.f2 hides the top level f2 inside module Mod , so Mod.f1 refers to Mod.f2 . You can refer to top level functions inside modules as shown in the example where Mod.f3 refers to f4 . If a \\where block contains a single definition, you can omit curly braces. Where blocks Every definition has an associated module with the same name. To add definitions to this module, you can write the \\where block at the end of this definition. Definitions defined in the associated module of a definition are visible inside this definition. \\func f = g \\where \\func g = 0 \\func h = f.g \\where \\data D \\where { \\func k = D \\func s = M.g.N.s } \\module M \\where \\func g = N.s \\where { \\module N \\where { \\func s = E } \\data E } Constructors of a \\data definition and fields of a \\class or a \\record definition are defined inside the module associated to the definition, but they are also visible outside this module. Open commands A module can be opened. This makes definitions defined inside this module visible in the current scope. The \\open command affects all definitions in the current scope. \\func h1 = f \\module M \\where { \\func f = 0 \\func g = 1 } \\open M \\func h2 = g The command \\open M (def_1, ... def_n) opens only definitions def_1 , ... def_n . Other definitions must be refered to by their full names. The command \\open M \\hiding (def_1, ... def_n) opens all of the definitions of M except for def_1 , ... def_n . These definitions still can be refered to by their full names. The command \\open M (def_1 \\as def_1', ... def_n \\as def_n') opens definitions def_1 , ... def_n , but renames them to def_1' , ... def_n' , respectively. If you want to open all of the definitions and rename some of them, use the command \\open M \\using (def_1 \\as def_1', ... def_n \\as def_n') . \\module M \\where { \\func f = 0 \\func g = 1 \\func h = 2 } \\module M1 \\where { \\open M (f,g) \\func h1 = f \\func h2 = g \\func h3 = M.h -- we can refer to M.h only by its full name. } \\module M2 \\where { \\open M \\hiding (f,g) \\func h1 = M.f -- we can refer to M.f and M.g only by their full names. \\func h2 = M.g \\func h3 = h } \\module M3 \\where { \\open M1 (h1 \\as M1_h1, h2) \\open M2 \\using (h2 \\as M2_h2) \\hiding (h3) \\func k1 = M1_h1 -- this refers to M1.h1 \\func k2 = h1 -- this refers to M2.h1 \\func k3 = h2 -- this refers to M1.h2 \\func k4 = M2_h2 -- this refers to M2.h2 \\func k5 = M1.h3 -- we can refer to M1.h3 only by its full name. } Note that if you open a module M inside a module M' and then open M' inside M'' , then definitions from M will not be visible in M'' . You need to explicitly open M inside M'' to make them visible. Import commands If you have several files, you can use the \\import command to make one of them visible in the other. For example, suppose that we have files A.vc , B.vc , a directory Dir , and a file Dir/C.vc with the following content: -- A.vc \\func a1 = 0 \\func a2 = 0 \\where \\func a3 = 0 -- Dir/C.vc \\import A \\func c1 = a1 \\func c2 = a2.a3 -- B.vc \\import Dir.C \\func b1 = c1 -- \\func b2 = a1 -- definitions from file A are not visible -- \\func b3 = A.a1 -- you cannot refer to definitions from file A by their full names. \\func b4 = Dir.C.c2 -- you can refer to definitions from file Dir/C.vc by their full names. The \\import command also opens the content of the imported file. You can use the same syntax as for \\open commands to control which definitions will be opened. If you want only import a file and not open any definitions, you can write \\import X () . Then you can refer to definitions defined in file X by their full names: -- X.vc \\func f = 0 -- Y.vc \\import X() \\func f = X.f","title":"Modules"},{"location":"language-reference/definitions/modules/#modules","text":"A module consists of a name and a list of definitions: \\module Mod \\where { def_1 ... def_n } You can refer to definitions def_1 ... def_n inside module Mod by their names. To refer to them outside this module, you need to use their full names Mod.def_1 ... Mod.def_n . For example, consider the following code: \\func f2 = Mod.f1 \\module Mod \\where { \\func f1 = f2 \\func f2 = 0 \\func f3 = f4 } \\func f4 = f2 You cannot refer to f1 in f2 without Mod. prefix. Function f4 refers to f2 defined on the top level. Function Mod.f2 hides the top level f2 inside module Mod , so Mod.f1 refers to Mod.f2 . You can refer to top level functions inside modules as shown in the example where Mod.f3 refers to f4 . If a \\where block contains a single definition, you can omit curly braces.","title":"Modules"},{"location":"language-reference/definitions/modules/#where-blocks","text":"Every definition has an associated module with the same name. To add definitions to this module, you can write the \\where block at the end of this definition. Definitions defined in the associated module of a definition are visible inside this definition. \\func f = g \\where \\func g = 0 \\func h = f.g \\where \\data D \\where { \\func k = D \\func s = M.g.N.s } \\module M \\where \\func g = N.s \\where { \\module N \\where { \\func s = E } \\data E } Constructors of a \\data definition and fields of a \\class or a \\record definition are defined inside the module associated to the definition, but they are also visible outside this module.","title":"Where blocks"},{"location":"language-reference/definitions/modules/#open-commands","text":"A module can be opened. This makes definitions defined inside this module visible in the current scope. The \\open command affects all definitions in the current scope. \\func h1 = f \\module M \\where { \\func f = 0 \\func g = 1 } \\open M \\func h2 = g The command \\open M (def_1, ... def_n) opens only definitions def_1 , ... def_n . Other definitions must be refered to by their full names. The command \\open M \\hiding (def_1, ... def_n) opens all of the definitions of M except for def_1 , ... def_n . These definitions still can be refered to by their full names. The command \\open M (def_1 \\as def_1', ... def_n \\as def_n') opens definitions def_1 , ... def_n , but renames them to def_1' , ... def_n' , respectively. If you want to open all of the definitions and rename some of them, use the command \\open M \\using (def_1 \\as def_1', ... def_n \\as def_n') . \\module M \\where { \\func f = 0 \\func g = 1 \\func h = 2 } \\module M1 \\where { \\open M (f,g) \\func h1 = f \\func h2 = g \\func h3 = M.h -- we can refer to M.h only by its full name. } \\module M2 \\where { \\open M \\hiding (f,g) \\func h1 = M.f -- we can refer to M.f and M.g only by their full names. \\func h2 = M.g \\func h3 = h } \\module M3 \\where { \\open M1 (h1 \\as M1_h1, h2) \\open M2 \\using (h2 \\as M2_h2) \\hiding (h3) \\func k1 = M1_h1 -- this refers to M1.h1 \\func k2 = h1 -- this refers to M2.h1 \\func k3 = h2 -- this refers to M1.h2 \\func k4 = M2_h2 -- this refers to M2.h2 \\func k5 = M1.h3 -- we can refer to M1.h3 only by its full name. } Note that if you open a module M inside a module M' and then open M' inside M'' , then definitions from M will not be visible in M'' . You need to explicitly open M inside M'' to make them visible.","title":"Open commands"},{"location":"language-reference/definitions/modules/#import-commands","text":"If you have several files, you can use the \\import command to make one of them visible in the other. For example, suppose that we have files A.vc , B.vc , a directory Dir , and a file Dir/C.vc with the following content: -- A.vc \\func a1 = 0 \\func a2 = 0 \\where \\func a3 = 0 -- Dir/C.vc \\import A \\func c1 = a1 \\func c2 = a2.a3 -- B.vc \\import Dir.C \\func b1 = c1 -- \\func b2 = a1 -- definitions from file A are not visible -- \\func b3 = A.a1 -- you cannot refer to definitions from file A by their full names. \\func b4 = Dir.C.c2 -- you can refer to definitions from file Dir/C.vc by their full names. The \\import command also opens the content of the imported file. You can use the same syntax as for \\open commands to control which definitions will be opened. If you want only import a file and not open any definitions, you can write \\import X () . Then you can refer to definitions defined in file X by their full names: -- X.vc \\func f = 0 -- Y.vc \\import X() \\func f = X.f","title":"Import commands"},{"location":"language-reference/definitions/parameters/","text":"Parameters Most kinds of definitions can have parameters. A parameter can be named or unnamed, explicit or implicit. Implicit parameters are always named. An unnamed parameter is simply an expression which denotes the type of the parameter. Syntax A named explicit parameter has the form (x : T) , where x is the name of the parameter and T is an expression which denotes the type of the parameter. An implicit parameter has the form {x : T} , where x and T are the same as before. Parameters are specified after the name of a definition. For example, all of the definitions below have three parameters: x1 of type A1 , x2 of type A2 , and x3 of type A3 . \\func f {x1 : A1} {x2 : A2} {x3 : A3} = 0 \\data D (x1 : A1) (x2 : A2) (x3 : A3) \\class C (x1 : A1) {x2 : A2} (x3 : A3) If several consecutive parameters have the same type, it can be specified only once by using the following syntax: x_1 ... x_n : T . For example, the following function has two implicit parameters of type A1 , three explicit parameters of type A2 , and one explicit parameter of type A3 : \\func f {x1 x2 : A1} (y1 y2 y3 : A2) (z : A3) = 0 This definition is equivalent to the following one: \\func f {x1 : A1} {x2 : A1} (y1 : A2) (y2 : A2) (y3 : A2) (z : A3) = 0 Parameters can be refered from the types of subsequent parameters and from the body of the definition. In the example above, parameters x1 and x2 may appear in A2 and A3 , parameters y1 , y2 , and y3 may appear in A3 , and all of the parameters may appear in the expression after = . If a pattern is never used anywhere, its name can be replaced with _ . Such a name cannot be refered to, so this simply indicated that this parameter is ignored. Implicit arguments Let f be a definition with parameters of types A_1 , ... A_n . If all of the parameters are explicit, then to we can form an expression of the form f a_1 ... a_n , where a_i is an expression of type A_i . Such an expression invokes f with the specified arguments. If some of the parameters of f are implicit, then corresponding arguments must be omitted. For example, consider the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f a1 a3 In the expression f a1 a3 , arguments corresponding to parameters y , y' , and z are omitted. The typechecker tries to infer these parameters and reports an error if it fails to do so. We can ask typechecker to try to infer an explicit parameter by writing _ instead of the corresponding argument: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ a3 In the example above, the typechecker will try to infer the argument corresponding to x . The expression _ can be written actually anywhere at all. The typechecker infers omitted expressions only when there is a unique solution that makes the definition in which they appear to typecheck. Finally, if the typechecker cannot infer an implicit argument, it can be specified explicitly by writing {e} . For example, to specify explicitly the second and the last arguments of f , we can write the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ {a2} a3 {a4} In this example, arguments corresponding to x and y' are left implicit and other arguments are explicitly specified.","title":"Parameters"},{"location":"language-reference/definitions/parameters/#syntax","text":"A named explicit parameter has the form (x : T) , where x is the name of the parameter and T is an expression which denotes the type of the parameter. An implicit parameter has the form {x : T} , where x and T are the same as before. Parameters are specified after the name of a definition. For example, all of the definitions below have three parameters: x1 of type A1 , x2 of type A2 , and x3 of type A3 . \\func f {x1 : A1} {x2 : A2} {x3 : A3} = 0 \\data D (x1 : A1) (x2 : A2) (x3 : A3) \\class C (x1 : A1) {x2 : A2} (x3 : A3) If several consecutive parameters have the same type, it can be specified only once by using the following syntax: x_1 ... x_n : T . For example, the following function has two implicit parameters of type A1 , three explicit parameters of type A2 , and one explicit parameter of type A3 : \\func f {x1 x2 : A1} (y1 y2 y3 : A2) (z : A3) = 0 This definition is equivalent to the following one: \\func f {x1 : A1} {x2 : A1} (y1 : A2) (y2 : A2) (y3 : A2) (z : A3) = 0 Parameters can be refered from the types of subsequent parameters and from the body of the definition. In the example above, parameters x1 and x2 may appear in A2 and A3 , parameters y1 , y2 , and y3 may appear in A3 , and all of the parameters may appear in the expression after = . If a pattern is never used anywhere, its name can be replaced with _ . Such a name cannot be refered to, so this simply indicated that this parameter is ignored.","title":"Syntax"},{"location":"language-reference/definitions/parameters/#implicit-arguments","text":"Let f be a definition with parameters of types A_1 , ... A_n . If all of the parameters are explicit, then to we can form an expression of the form f a_1 ... a_n , where a_i is an expression of type A_i . Such an expression invokes f with the specified arguments. If some of the parameters of f are implicit, then corresponding arguments must be omitted. For example, consider the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f a1 a3 In the expression f a1 a3 , arguments corresponding to parameters y , y' , and z are omitted. The typechecker tries to infer these parameters and reports an error if it fails to do so. We can ask typechecker to try to infer an explicit parameter by writing _ instead of the corresponding argument: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ a3 In the example above, the typechecker will try to infer the argument corresponding to x . The expression _ can be written actually anywhere at all. The typechecker infers omitted expressions only when there is a unique solution that makes the definition in which they appear to typecheck. Finally, if the typechecker cannot infer an implicit argument, it can be specified explicitly by writing {e} . For example, to specify explicitly the second and the last arguments of f , we can write the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ {a2} a3 {a4} In this example, arguments corresponding to x and y' are left implicit and other arguments are explicitly specified.","title":"Implicit arguments"},{"location":"language-reference/definitions/records/","text":"Records TODO","title":"Records"},{"location":"language-reference/expressions/case/","text":"Case TODO","title":"Case"},{"location":"language-reference/expressions/class-ext/","text":"Class extensions TODO","title":"Class extensions"},{"location":"language-reference/expressions/goals/","text":"Goals TODO","title":"Goals"},{"location":"language-reference/expressions/let/","text":"Let TODO","title":"Let"},{"location":"language-reference/expressions/pi/","text":"Pi expressions TODO","title":"Pi types"},{"location":"language-reference/expressions/sigma/","text":"Sigma expressions TODO","title":"Sigma types"},{"location":"language-reference/expressions/universes/","text":"Universes TODO","title":"Universes"},{"location":"tutorial/","text":"Tutorial Functions Pattern Matching","title":"Table of Contents"},{"location":"tutorial/functions/","text":"Functions TODO","title":"Functions"},{"location":"tutorial/pattern-matching/","text":"Pattern Matching TODO","title":"Pattern Matching"}]}