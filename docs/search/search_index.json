{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Arend (aka vclang) is a theorem prover based on Homotopy Type Theory . For the installation instructions, see this section . The section Language Reference contains a description of the Arend language. For a tutorial, see this section .","title":"Overview"},{"location":"getting-started/","text":"Getting Started You need to have JRE 8 installed on your computer to use Arend. Arend is available either as an IntelliJ IDEA plugin (see this section for the installation instructions) or as a console applications (see this section for the installation instructions). IntelliJ IDEA Plugin To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-vclang.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Vclang in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file project_name .vcl and an empty directory src . The vcl file contains a description of the project. Create a new file example.vc in src directory. Add the following line to this file: \\func f = 0 Right click example.vc file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.vc:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference . Console Application To install the console application, follow the instructions below. Download the vclang jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar vclang.jar to check that everything is alright. You should see the following output: $ java -jar vclang.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar vclang.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file myProject.vcl inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to myProject.vcl : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.vc inside src with the following content: \\func f = 0 Run java -jar $vclang $myProject , where $vclang is the path to vclang.jar and $myProject is the path to myProject.vcl . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.vc as follows: \\func f : Nat - Nat = 0 If you run java -jar $vclang $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Getting Started"},{"location":"getting-started/#intellij-idea-plugin","text":"To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-vclang.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Vclang in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file project_name .vcl and an empty directory src . The vcl file contains a description of the project. Create a new file example.vc in src directory. Add the following line to this file: \\func f = 0 Right click example.vc file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.vc:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference .","title":"IntelliJ IDEA Plugin"},{"location":"getting-started/#console-application","text":"To install the console application, follow the instructions below. Download the vclang jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar vclang.jar to check that everything is alright. You should see the following output: $ java -jar vclang.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar vclang.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file myProject.vcl inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to myProject.vcl : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.vc inside src with the following content: \\func f = 0 Run java -jar $vclang $myProject , where $vclang is the path to vclang.jar and $myProject is the path to myProject.vcl . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.vc as follows: \\func f : Nat - Nat = 0 If you run java -jar $vclang $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Console Application"},{"location":"language-reference/","text":"Language Reference Lexical Structure Definitions Modules Functions Data Records Classes Instances Implicit Arguments Coercion Expressions Goals Universes Let Case","title":"Table of Contents"},{"location":"language-reference/definitions/","text":"Definitions Arend has the following definitions: functions , data , records , classes , instances , and coercions . Every definition has a name which must be a valid identifier as described here . Definitions can be referred by their names. If we defined a definition named def , then we can write the following expression: def e_1 ... e_n , where e_1 , ..., e_n are expressions. Such an expression is called defcall . Expressions e_1 , ..., e_n are called arguments of this defcall. If we have only two parameters, we can write a defcall in the infix notation: e_1 `def` e_2 . This expression is equivalent to def e_1 e_2 . If we have only one parameter, we can use the postfix notation: e_1 `def . This expression is equivalent to def e_1 . Precedence To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 . Infix operators A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Definitions"},{"location":"language-reference/definitions/#precedence","text":"To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 .","title":"Precedence"},{"location":"language-reference/definitions/#infix-operators","text":"A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Infix operators"},{"location":"language-reference/expressions/","text":"Expressions TODO","title":"Expressions"},{"location":"language-reference/lexical-structure/","text":"Lexical Structure Keywords All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type . Numerals A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers. Identifiers An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - . Infix and postfix notation A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section . Comments Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Lexical Structure"},{"location":"language-reference/lexical-structure/#keywords","text":"All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type .","title":"Keywords"},{"location":"language-reference/lexical-structure/#numerals","text":"A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers.","title":"Numerals"},{"location":"language-reference/lexical-structure/#identifiers","text":"An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - .","title":"Identifiers"},{"location":"language-reference/lexical-structure/#infix-and-postfix-notation","text":"A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section .","title":"Infix and postfix notation"},{"location":"language-reference/lexical-structure/#comments","text":"Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Comments"},{"location":"language-reference/definitions/classes/","text":"Classes TODO","title":"Classes"},{"location":"language-reference/definitions/coercion/","text":"Coercion TODO","title":"Coercion"},{"location":"language-reference/definitions/data/","text":"Data Definitions TODO","title":"Data Definitions"},{"location":"language-reference/definitions/functions/","text":"Functions Definitions TODO","title":"Function Definitions"},{"location":"language-reference/definitions/implicit-arguments/","text":"Implicit Arguments TODO","title":"Implicit Arguments"},{"location":"language-reference/definitions/instances/","text":"Instances TODO","title":"Instances"},{"location":"language-reference/definitions/modules/","text":"Modules TODO","title":"Modules"},{"location":"language-reference/definitions/records/","text":"Records TODO","title":"Records"},{"location":"language-reference/expressions/case/","text":"Case TODO","title":"Case"},{"location":"language-reference/expressions/goals/","text":"Goals TODO","title":"Goals"},{"location":"language-reference/expressions/let/","text":"Let TODO","title":"Let"},{"location":"language-reference/expressions/universes/","text":"Universes TODO","title":"Universes"},{"location":"tutorial/","text":"Tutorial Functions Pattern Matching","title":"Table of Contents"},{"location":"tutorial/functions/","text":"Functions TODO","title":"Functions"},{"location":"tutorial/pattern-matching/","text":"Pattern Matching TODO","title":"Pattern Matching"}]}