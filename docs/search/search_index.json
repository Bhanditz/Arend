{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Arend is a theorem prover based on Homotopy Type Theory . For the installation instructions, see this section . The section Language Reference contains a description of the Arend language. For a tutorial, see this section .","title":"Overview"},{"location":"getting-started/","text":"Getting Started You need to have JRE 8 installed on your computer to use Arend. Arend is available either as an IntelliJ IDEA plugin (see this section for the installation instructions) or as a console applications (see this section for the installation instructions). IntelliJ IDEA Plugin To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-arend.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Arend in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file arend.yaml and an empty directory src . The yaml file contains a description of the project. Create a new file example.ard in src directory. Add the following line to this file: \\func f = 0 Right click example.ard file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.ard:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference . Console Application To install the console application, follow the instructions below. Download the arend jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar arend.jar to check that everything is alright. You should see the following output: $ java -jar arend.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar arend.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file arend.yaml inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to arend.yaml : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.ard inside src with the following content: \\func f = 0 Run java -jar $arend $myProject , where $arend is the path to arend.jar and $myProject is the path to arend.yaml . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.ard as follows: \\func f : Nat - Nat = 0 If you run java -jar $arend $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Getting Started"},{"location":"getting-started/#intellij-idea-plugin","text":"To install the IntelliJ IDEA plugin, follow the instructions below. Download (either community or ultimate version of) IntelliJ IDEA . Download the Arend plugin . You can also get the latest version of the plugin by following instructions on this page . Run Intellij IDEA, choose either Configure | Plugins if you are on a Welcome screen or File | Settings from the main menu if a project is open, go to Plugins tab, click Install plugin from disk , choose downloaded intellij-arend.zip file, restart Intellij IDEA. Let's create our first Arend project. Run Intellij IDEA and choose either Create New Project if you are on a Welcome screen or File | New | Project from the main menu if a project is open. Choose Arend in the list on the left, click Next , click Finish . You should get a new project which contains (among other files) a file arend.yaml and an empty directory src . The yaml file contains a description of the project. Create a new file example.ard in src directory. Add the following line to this file: \\func f = 0 Right click example.ard file and choose Run 'Typecheck example' in the popup menu (you can also use shortcut Alt+Shift+F10 ). You should see the message All Tests Passed , which indicates that the typechecking was successful. Modify the file as follows: \\func f : Nat - Nat = 0 Run the typechecking again (you can use shortcut Shift+F10 for this). You should see the following error message: [ERROR] example.ard:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f You can read more about IntelliJ IDEA here . To learn more about Arend, see the tutorial and the language reference .","title":"IntelliJ IDEA Plugin"},{"location":"getting-started/#console-application","text":"To install the console application, follow the instructions below. Download the arend jar file . You can also get the latest version of the plugin by following instructions on this page . Run java -jar arend.jar to check that everything is alright. You should see the following output: $ java -jar arend.jar [INFO] Loading library prelude [INFO] Loaded library prelude Nothing to load To see command line options, run java -jar arend.jar --help . Let's create our first Arend project. Create a directory for your project: $ mkdir testProject $ cd testProject Create file arend.yaml inside this directory. This file contains the description of your project. Currently, we just need to specify the location of source files of your project. Add the following line to arend.yaml : sourcesDir: src Create directory src which will contain source files for this project. Create a file example.ard inside src with the following content: \\func f = 0 Run java -jar $arend $myProject , where $arend is the path to arend.jar and $myProject is the path to arend.yaml . You should see the following output: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ ] example --- Done --- This means that module example was successfully typechecked. Modify file example.ard as follows: \\func f : Nat - Nat = 0 If you run java -jar $arend $myProject again, it should produce the following error message: [INFO] Loading library prelude [INFO] Loaded library prelude [INFO] Loading library myProject [INFO] Loaded library myProject --- Typechecking myProject --- [ERROR] example:1:25: Type mismatch Expected type: Nat - Nat Actual type: Nat In: 0 While processing: f [\u2717] example Number of modules with errors: 1 --- Done ---","title":"Console Application"},{"location":"language-reference/","text":"Language Reference Lexical structure Definitions Modules Parameters Function definitions Data definitions Higher inductive types Records Classes Instances Coercion Expressions Goals Universes Pi types Sigma types Let Case Class extensions Prelude","title":"Table of Contents"},{"location":"language-reference/definitions/","text":"Definitions Arend has the following definitions: functions , data , records , classes , instances , and coercions . Every definition has a name which must be a valid identifier as described here . Definitions can be referred by their names. If we defined a definition named def , then we can write the following expression: def e_1 ... e_n , where e_1 , ..., e_n are expressions. Such an expression is called defcall . Expressions e_1 , ..., e_n are called arguments of this defcall. If we have only two parameters, we can write a defcall in the infix notation: e_1 `def` e_2 . This expression is equivalent to def e_1 e_2 . If we have only one parameter, we can use the postfix notation: e_1 `def . This expression is equivalent to def e_1 . Precedence To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 . Infix operators A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Definitions"},{"location":"language-reference/definitions/#precedence","text":"To parse expressions which have more than one infix or postfix notations in them, we need to know the precedence of involved definitions. It can be specified by keywords \\fixl for left associative names, \\fixr for right associative names, and \\fix for non-associative names. Such a keyword together with a number between 1 and 9 is specified before the name of the definition in its declaration. For example, \\fixl 3 def1 defines a definition named def1 which is left associative with priority 3. If we have another definition \\fixr 4 def2 , then expression e1 `def1` e2 `def2` e3 is parsed as e1 `def1` (e2 `def2` e3) since the priority of def2 is higher than the priority of def1 . If they have the same priority and they are both left associative, then this expression is parsed as (e1 `def1` e2) `def2` e3 . If they have the same priority and their associativities differ or one of them is non-associative, then this expression cannot be parsed and produces an error message. The default precedence is \\fixr 10 .","title":"Precedence"},{"location":"language-reference/definitions/#infix-operators","text":"A definition can be defined as an infix operator . This means that its defcalls are parsed as infix notations even without ` ` . Infix operators are defined by specifying one of keywords \\infixl , \\infixr , \\infix before the name of the definition. These keyords have the same syntax and semantics as keywords \\fixl , \\fixr , and \\fix that we described before. An infix operator can be used in the prefix form as ordinary definition. For example, if we have a function defined as \\infixl 6 + , then we can write either + 1 2 or 1 + 2 ; these expressions are equivalent. Finally, if f is an infix operator or an infix notation, then we can write e f which is equivalent to f e . For example, we can write the function that adds 1 to its argument either as 1 + or as + 1 . If we apply the first function to 2, then we get 1 + 2 and if we apply the second one to 2, then we get + 1 2 and as noted before these expressions are equivalent.","title":"Infix operators"},{"location":"language-reference/expressions/","text":"Expressions An expression denotes a value which may depend on some variables. The basic example of an expression is simply a variable x . Of course, x must be defined somewhere in order for such an expression to make sense. It can be either a parameter (of a definition , or a lambda expression , or a pi expression , or a sigma expression ), a variable define in a let expression , or a variable defined in a pattern . If e , e_1 , ... e_n are expressions and x_1 , ... x_n are variables, then we will write e[e_1/x_1, ... e_n/x_n] for the substitution operation. This is a meta-operation, that is it is a function on the set of expressions of the language and not an expression itself. The expression e[e_1/x_1, ... e_n/x_n] is simply e in which every occurrence of each of the variables x_i is replaced with the expression e_i . Evaluation There is a binary relation = on the set of expressions called the reduction relation . If e_1 = ... = e_n , we will say that e_1 reduces to e_n . If there is no e' such that e = e' , we will say that e is a normal form . If e reduces to e' and e' is a normal form, we will say that e' is a normal form of e and that e evaluates to e' . Every expression has a unique normal form. The relation = is a meta-relation on the set of expressions of the language, that is you cannot refer to it explicitly in the language. This relation is used by the typechecker to compare expressions. The typechecker never compares expressions directly. To compare expressions e_1 and e_2 , it first evaluates their normal forms and then compares them. Since normal forms always exist, the comparison algorithm always terminates, but it is easy to write an expression that does not evaluate in any reasonable time. Types Every expression has a type. The fact that an expression e has type E is denoted by e : E . A type is an expression which has type \\Type . The expression \\Type is discussed in this section . Every variable has a type which is specified when the variable is defined (or can be inferred). An expression of the form x has the type of the variable x . The type of an expression usually can be inferred automatically, but sometimes it is useful to specify it explicitly. An expression of the form (e : E) (parentheses are necessary) is equivalent to e , but also has an explicit type annotation. In this expression, e must have type E and the type of the whole expression is also E (since it is equivalent to e ). Defcalls A defcall is an expression of the form f a_1 ... a_n , where f is a definition with n parameters (an exception is classes and records in which case only expressions without arguments are called defcalls, see this section for the discussion of such expressions). If f is a definition with parameters x_1 , ... x_n and the result type R , then the type of a defcall f a_1 ... a_n is R[a_1/x_1, ... a_n/x_n] . If f is either a class, a record, a data type, a constructor without conditions, an instance, or a function defined by copattern matching, then f a_1 ... a_n is a normal form whenever a_1 , ... a_n are. If f is a function defined as \\func f (x_1 : A_1) ... (x_n : A_n) = e , then f a_1 ... a_n reduces to e[a_1/x_1, ... a_n/x_n] . If f is a function defined by pattern matching or a constructor with conditions, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f is an instance or a function defined by copattern matching, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f has n parameters and k n, you can write f a_1 ... a_k and such an expression is equivalent to \\lam a_{k+1} ... a_n = f a_1 ... a_n .","title":"Expressions"},{"location":"language-reference/expressions/#evaluation","text":"There is a binary relation = on the set of expressions called the reduction relation . If e_1 = ... = e_n , we will say that e_1 reduces to e_n . If there is no e' such that e = e' , we will say that e is a normal form . If e reduces to e' and e' is a normal form, we will say that e' is a normal form of e and that e evaluates to e' . Every expression has a unique normal form. The relation = is a meta-relation on the set of expressions of the language, that is you cannot refer to it explicitly in the language. This relation is used by the typechecker to compare expressions. The typechecker never compares expressions directly. To compare expressions e_1 and e_2 , it first evaluates their normal forms and then compares them. Since normal forms always exist, the comparison algorithm always terminates, but it is easy to write an expression that does not evaluate in any reasonable time.","title":"Evaluation"},{"location":"language-reference/expressions/#types","text":"Every expression has a type. The fact that an expression e has type E is denoted by e : E . A type is an expression which has type \\Type . The expression \\Type is discussed in this section . Every variable has a type which is specified when the variable is defined (or can be inferred). An expression of the form x has the type of the variable x . The type of an expression usually can be inferred automatically, but sometimes it is useful to specify it explicitly. An expression of the form (e : E) (parentheses are necessary) is equivalent to e , but also has an explicit type annotation. In this expression, e must have type E and the type of the whole expression is also E (since it is equivalent to e ).","title":"Types"},{"location":"language-reference/expressions/#defcalls","text":"A defcall is an expression of the form f a_1 ... a_n , where f is a definition with n parameters (an exception is classes and records in which case only expressions without arguments are called defcalls, see this section for the discussion of such expressions). If f is a definition with parameters x_1 , ... x_n and the result type R , then the type of a defcall f a_1 ... a_n is R[a_1/x_1, ... a_n/x_n] . If f is either a class, a record, a data type, a constructor without conditions, an instance, or a function defined by copattern matching, then f a_1 ... a_n is a normal form whenever a_1 , ... a_n are. If f is a function defined as \\func f (x_1 : A_1) ... (x_n : A_n) = e , then f a_1 ... a_n reduces to e[a_1/x_1, ... a_n/x_n] . If f is a function defined by pattern matching or a constructor with conditions, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f is an instance or a function defined by copattern matching, then the evaluation of defcalls f a_1 ... a_n is described in this section . If f has n parameters and k n, you can write f a_1 ... a_k and such an expression is equivalent to \\lam a_{k+1} ... a_n = f a_1 ... a_n .","title":"Defcalls"},{"location":"language-reference/lexical-structure/","text":"Lexical Structure Keywords All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type . Numerals A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers. Identifiers An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - . Infix and postfix notation A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section . Comments Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Lexical Structure"},{"location":"language-reference/lexical-structure/#keywords","text":"All Arend's keywords begin with \\ . The complete list of keywords: \\open \\import \\hiding \\as \\using \\truncated \\data \\func \\class \\record \\extends \\module \\instance \\coerce \\with \\elim \\cowith \\where \\infix \\infixl \\infixr \\fix \\fixl \\fixr \\new \\Pi \\Sigma \\lam \\let \\in \\case \\return \\lp \\lh \\suc \\max \\levels \\Prop \\Set \\Type .","title":"Keywords"},{"location":"language-reference/lexical-structure/#numerals","text":"A positive numeral is a non-empty sequence of numbers. A negative numeral consists of - followed by a non-empty sequence of numbers.","title":"Numerals"},{"location":"language-reference/lexical-structure/#identifiers","text":"An identifier consists of a non-empty sequence of lower and upper case letters, numbers, and symbols from the list ~!@#$%^ *-+= ?/|[];:_ . Exceptions are sequences that begin with a number, sequences that begin with -- , numerals, and reserved names: - , = , _ , : , and | . Examples: Valid identifiers: xxx , + , $^~]!005x , :: , - x , x:Nat , -5b , -33+7 . Invalid identifiers: --xxx , 5b , -33 , - .","title":"Identifiers"},{"location":"language-reference/lexical-structure/#infix-and-postfix-notation","text":"A postfix notation is an identifier followed by ` . An infix notation is an identifier surrounded by ` . Both of these notations are described in this section .","title":"Infix and postfix notation"},{"location":"language-reference/lexical-structure/#comments","text":"Multi-line comments are enclosed in {- and -} and can be nested. Single-line comments consist of -- followed by an arbitrary text until the end of the line. The exception is identifiers which include -- in their names, but do not begin with -- . This means that -- , -------- , --| , --foo , and -------foobar are comments and |-- , %--foo , and x------foobar are not.","title":"Comments"},{"location":"language-reference/prelude/","text":"Prelude Prelude is a built-in module which contains several definitions which behave differently from ordinary definitions. It is also always imported implicitly in every module. You can import it explicitly to hide or rename some of its definitions. We will discuss definitions in this module. You can find file Prelude.ard which contains these definitions, but note that they are only roughly correspond to actual definitions since most of them cannot be actually defined in the ordinary syntax. Nat and Int The definitions of Nat , Int , Nat.+ , Nat.* , and Int.fromNat are actually correct, you can define the same definitions in an ordinary file. The difference is that the definitions from Prelude are implemented more efficiently. Interval The definition of the interval type \\data I | left | right looks like the definition of the set with two elements, but this is not true actually. One way to think about this data type is that it has more constructors to which you cannot refer explicitly. This means that you cannot define a function on I by pattern matching. Path The definition of Path A a a' is not correct. By the definition, it should consists of all functions \\Pi (i : I) - A i , but actually it consists of all such functions f which also satisfy equations f left = a and f right = a' , where the equality is computational. This means that when you write path f the typechecker also checks that this equations hold and if they don't it produces an error message. For example, if you write \\func test : 1 = 0 = path (\\lam _ = 0) , you will see the following error message: [ERROR] test.ard:1:23: The left path endpoint mismatch Expected: 1 Actual: 0 In: path (\\lam _ = 0) While processing: test The type of Path is also computed differently. If A is an (n+1)-type, then Path A a a' is an n-type. Otherwise, it has the same level as A . Prelude also contains an infix form of Path called = which is actually a correctly defined function. The definition of @ is also correct, but the typechecker has an eta rule for this definition: path (\\lam i = p @ i) = p . This rule does not hold for functions @ defined in other files. coe Function coe imples that I is contractible and that = satisfies the rules for ordinary identity types. The definition of coe is not correct since it pattern matches on the interval. iso The definition of iso is not correct since it also pattern matches on the interval. This definition implies the univalence axiom. TrP and TrS Data types TrP and TrS define propositional and set truncations. They will be either removed or replaced with some other definitions in future releases.","title":"Prelude"},{"location":"language-reference/prelude/#nat-and-int","text":"The definitions of Nat , Int , Nat.+ , Nat.* , and Int.fromNat are actually correct, you can define the same definitions in an ordinary file. The difference is that the definitions from Prelude are implemented more efficiently.","title":"Nat and Int"},{"location":"language-reference/prelude/#interval","text":"The definition of the interval type \\data I | left | right looks like the definition of the set with two elements, but this is not true actually. One way to think about this data type is that it has more constructors to which you cannot refer explicitly. This means that you cannot define a function on I by pattern matching.","title":"Interval"},{"location":"language-reference/prelude/#path","text":"The definition of Path A a a' is not correct. By the definition, it should consists of all functions \\Pi (i : I) - A i , but actually it consists of all such functions f which also satisfy equations f left = a and f right = a' , where the equality is computational. This means that when you write path f the typechecker also checks that this equations hold and if they don't it produces an error message. For example, if you write \\func test : 1 = 0 = path (\\lam _ = 0) , you will see the following error message: [ERROR] test.ard:1:23: The left path endpoint mismatch Expected: 1 Actual: 0 In: path (\\lam _ = 0) While processing: test The type of Path is also computed differently. If A is an (n+1)-type, then Path A a a' is an n-type. Otherwise, it has the same level as A . Prelude also contains an infix form of Path called = which is actually a correctly defined function. The definition of @ is also correct, but the typechecker has an eta rule for this definition: path (\\lam i = p @ i) = p . This rule does not hold for functions @ defined in other files.","title":"Path"},{"location":"language-reference/prelude/#coe","text":"Function coe imples that I is contractible and that = satisfies the rules for ordinary identity types. The definition of coe is not correct since it pattern matches on the interval.","title":"coe"},{"location":"language-reference/prelude/#iso","text":"The definition of iso is not correct since it also pattern matches on the interval. This definition implies the univalence axiom.","title":"iso"},{"location":"language-reference/prelude/#trp-and-trs","text":"Data types TrP and TrS define propositional and set truncations. They will be either removed or replaced with some other definitions in future releases.","title":"TrP and TrS"},{"location":"language-reference/definitions/classes/","text":"Classes TODO","title":"Classes"},{"location":"language-reference/definitions/coercion/","text":"Coercion TODO","title":"Coercion"},{"location":"language-reference/definitions/data/","text":"Data Definitions Data definitions generalize allow us to define (higher) inductive types. Each data definition has several constructors. Constructors belong to the module associated to the data definition, but they are also visible in the module in which the data type is defined: \\data D | con1 | con2 \\func f = con1 \\func g = con2 \\func f' = D.con1 \\func g' = D.con2 In the example above, we defined a data type D with two constructors con1 and con2 . Functions f and f' (as well as g and g' ) are equivalent. Syntax The basic syntax of a data definition looks like this: \\data D p_1 ... p_n | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} where p_1 , ... p_n , p^1_1 , ... p^m_{k_m} are either named or unnamed parameters . There are several extensions of this syntax which we will discuss later. Each row con_i p^i_1 ... p^i_{k_i} defines a constructor con_i with the specified parameters. Parameters p_1 , ... p_n are parameters of the data type D , but they also become implicit parameters of constructors. Let A , ... F be some types and let a , ... f be terms of the corresponding types. Consider the following example: \\data Data A B | cons {C} D E | cons' \\func s1 = Data a b \\func s2 = cons d e \\func s2' = cons {a} d e \\func s2'' = cons {a} {b} {c} d e \\func s3 = cons' \\func s3' = cons' {a} \\func s3'' = cons' {a} {b} Constructor cons has three implicit parameters of types A , B , and C and two explicit parameters of types D and E . Constructor cons' has only two implicit parameters of types A and B . The type of a defcall con_i {a_1} ... {a_n} b_1 ... b_{k_i} is D a_1 ... a_n . The type of a defcall D a_1 ... a_n is of the form \\h-Type p . Levels h and p are calculated automatically, but you can also specify explicitly the level of a data type: \\data D p_1 ... p_n : \\h-Type p | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} If the actual type of D does not fit into the specified levels, the typechecker will generate an error message. Inductive definitions A data definition can be recursive, that is D may appear in parameters p^1_1 , ... p^m_{k_m} (but not in p_1 , ... p_n ). Such recursive definitions are called inductive data types . They have one restriction: recursive calls to D may occur only in strictly positive positions. The set of such positions is defined inductively: D occurs only in strictly positive positions in D a_1 ... a_n if it does not occur in a_1 , ... a_n . D occurs only in strictly positive positions in \\Pi (x : A) - B if it occurs only in strictly positive positions in B and does not occur in A . D occurs only in strictly positive positions in Path (\\lam i = B) b b' if it occurs only in strictly positive positions in B and does not occur in b and b' . D occurs only in strictly positive positions in any other expression if it does not occur in it. Truncation You can truncate data types to a specified homotopy level which is less than its actual level. To do this, specify explicitly the type of a data definition and write keyword \\truncated before the definition: \\truncated \\data D p_1 ... p_n : \\h-Type p | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} If the actual predicative level of D is greater than p , the typechecker will generate an error message, but h can be any number. Such a data type can be eliminated only into types of the same homotopy level. Consider the following example: \\truncated \\data Exists (A : \\Type) (B : A - \\Type) : \\Prop | witness (a : A) (B a) {- -- This function will not typecheck. \\func extract (p : Exists (n : Nat) (n = 3)) : Nat | witness a b = a -} \\func existsSuc (p : Exists (n : Nat) (n = 3)) : Exists (n : Nat) (suc n = 4) | witness n p = witness (suc n) (path (\\lam i = suc (p @ i))) \\func existsEq (p : Exists (n : Nat) (n = 3)) : 0 = 0 | witness n p = path (\\lam _ = 0) The data type Exists defines a proposition 'There is an a : A such that B a '. The function extract which extracts a natural number from the proof that there exists a natural number which equals to 3 is incorrect, but functions existsSuc and existsEq which construct another proofs are accepted. A truncated data type is (provably) equivalent to the truncation of the untrancated version of this data type. So, this is simply a syntax sugar that allows you to define functions over a truncated data type more easily. Induction-induction and induction-recursion Two or more data types can be mutually recursive. This is called induction-induction . Inductive-inductive definitions also must be strictly positive. That is, recursive calls to the definition itself and to other recursive definitions may occur only in strictly positive positions. Data types may also be mutually recusrive with functions. This is called induction-recursion . Strict positivity and termination checkers work as usual for such definitions. Varying number of constructors Sometimes we need to define a data type which has different constructors depending on its parameters. The classical example is the data type of lists of fixed length. The data type Vec A 0 has only one constructor nil , the empty list. The data type Vec A (suc n) also has one constructor cons , a non-empty list. We can define such a data type by 'pattern-matching': \\data Vec (A : \\Type) (n : Nat) \\elim n | 0 = nil | suc n = cons A (Vec A n) The general syntax is similar to the syntax of functions defined by pattern-matching. After the list of parameters we can write either \\elim vars or \\with followed by a list of clause. \\data D p_1 ... p_n \\with | t_1, ... t_n = con_1 p^1_1 ... p^1_{k_1} ... | t_1', ... t_n' = con_m p^m_1 ... p^m_{k_m} Each clause has a list of patterns, followed by = , followed by a constructor definition. The order of clauses does not matter. If a clause matches the arguments of a defcall D a_1 ... a_n , then the corresponding constructor is added to this data type. For example, we can define the following data type: \\data Bool | true | false \\data T (b : Bool) \\with | true = con1 | true = con2 Data type T true has two constructors: con1 and con2 . Data type T false is empty. We can also define several constructors in a single clause as follows: \\data T (b : Bool) \\with | true = { | con1 | con2 } This definition is equivalent to the previous one.","title":"Data Definitions"},{"location":"language-reference/definitions/data/#syntax","text":"The basic syntax of a data definition looks like this: \\data D p_1 ... p_n | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} where p_1 , ... p_n , p^1_1 , ... p^m_{k_m} are either named or unnamed parameters . There are several extensions of this syntax which we will discuss later. Each row con_i p^i_1 ... p^i_{k_i} defines a constructor con_i with the specified parameters. Parameters p_1 , ... p_n are parameters of the data type D , but they also become implicit parameters of constructors. Let A , ... F be some types and let a , ... f be terms of the corresponding types. Consider the following example: \\data Data A B | cons {C} D E | cons' \\func s1 = Data a b \\func s2 = cons d e \\func s2' = cons {a} d e \\func s2'' = cons {a} {b} {c} d e \\func s3 = cons' \\func s3' = cons' {a} \\func s3'' = cons' {a} {b} Constructor cons has three implicit parameters of types A , B , and C and two explicit parameters of types D and E . Constructor cons' has only two implicit parameters of types A and B . The type of a defcall con_i {a_1} ... {a_n} b_1 ... b_{k_i} is D a_1 ... a_n . The type of a defcall D a_1 ... a_n is of the form \\h-Type p . Levels h and p are calculated automatically, but you can also specify explicitly the level of a data type: \\data D p_1 ... p_n : \\h-Type p | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} If the actual type of D does not fit into the specified levels, the typechecker will generate an error message.","title":"Syntax"},{"location":"language-reference/definitions/data/#inductive-definitions","text":"A data definition can be recursive, that is D may appear in parameters p^1_1 , ... p^m_{k_m} (but not in p_1 , ... p_n ). Such recursive definitions are called inductive data types . They have one restriction: recursive calls to D may occur only in strictly positive positions. The set of such positions is defined inductively: D occurs only in strictly positive positions in D a_1 ... a_n if it does not occur in a_1 , ... a_n . D occurs only in strictly positive positions in \\Pi (x : A) - B if it occurs only in strictly positive positions in B and does not occur in A . D occurs only in strictly positive positions in Path (\\lam i = B) b b' if it occurs only in strictly positive positions in B and does not occur in b and b' . D occurs only in strictly positive positions in any other expression if it does not occur in it.","title":"Inductive definitions"},{"location":"language-reference/definitions/data/#truncation","text":"You can truncate data types to a specified homotopy level which is less than its actual level. To do this, specify explicitly the type of a data definition and write keyword \\truncated before the definition: \\truncated \\data D p_1 ... p_n : \\h-Type p | con_1 p^1_1 ... p^1_{k_1} ... | con_m p^m_1 ... p^m_{k_m} If the actual predicative level of D is greater than p , the typechecker will generate an error message, but h can be any number. Such a data type can be eliminated only into types of the same homotopy level. Consider the following example: \\truncated \\data Exists (A : \\Type) (B : A - \\Type) : \\Prop | witness (a : A) (B a) {- -- This function will not typecheck. \\func extract (p : Exists (n : Nat) (n = 3)) : Nat | witness a b = a -} \\func existsSuc (p : Exists (n : Nat) (n = 3)) : Exists (n : Nat) (suc n = 4) | witness n p = witness (suc n) (path (\\lam i = suc (p @ i))) \\func existsEq (p : Exists (n : Nat) (n = 3)) : 0 = 0 | witness n p = path (\\lam _ = 0) The data type Exists defines a proposition 'There is an a : A such that B a '. The function extract which extracts a natural number from the proof that there exists a natural number which equals to 3 is incorrect, but functions existsSuc and existsEq which construct another proofs are accepted. A truncated data type is (provably) equivalent to the truncation of the untrancated version of this data type. So, this is simply a syntax sugar that allows you to define functions over a truncated data type more easily.","title":"Truncation"},{"location":"language-reference/definitions/data/#induction-induction-and-induction-recursion","text":"Two or more data types can be mutually recursive. This is called induction-induction . Inductive-inductive definitions also must be strictly positive. That is, recursive calls to the definition itself and to other recursive definitions may occur only in strictly positive positions. Data types may also be mutually recusrive with functions. This is called induction-recursion . Strict positivity and termination checkers work as usual for such definitions.","title":"Induction-induction and induction-recursion"},{"location":"language-reference/definitions/data/#varying-number-of-constructors","text":"Sometimes we need to define a data type which has different constructors depending on its parameters. The classical example is the data type of lists of fixed length. The data type Vec A 0 has only one constructor nil , the empty list. The data type Vec A (suc n) also has one constructor cons , a non-empty list. We can define such a data type by 'pattern-matching': \\data Vec (A : \\Type) (n : Nat) \\elim n | 0 = nil | suc n = cons A (Vec A n) The general syntax is similar to the syntax of functions defined by pattern-matching. After the list of parameters we can write either \\elim vars or \\with followed by a list of clause. \\data D p_1 ... p_n \\with | t_1, ... t_n = con_1 p^1_1 ... p^1_{k_1} ... | t_1', ... t_n' = con_m p^m_1 ... p^m_{k_m} Each clause has a list of patterns, followed by = , followed by a constructor definition. The order of clauses does not matter. If a clause matches the arguments of a defcall D a_1 ... a_n , then the corresponding constructor is added to this data type. For example, we can define the following data type: \\data Bool | true | false \\data T (b : Bool) \\with | true = con1 | true = con2 Data type T true has two constructors: con1 and con2 . Data type T false is empty. We can also define several constructors in a single clause as follows: \\data T (b : Bool) \\with | true = { | con1 | con2 } This definition is equivalent to the previous one.","title":"Varying number of constructors"},{"location":"language-reference/definitions/functions/","text":"Functions Definitions Functions in Arend are functions in the mathematical sense. They can have arbitrary arity. In particular, constants in Arend are just functions of arity 0. A definition of a function consists of its name, a signature which consists of a list of parameters and (possibly) a result type, and a body which is an expression that describes the behaviour of the function. Non-recursive functions To define a non-recursive function, write \\func f p_1 ... p_n = e , where f is the name of the function, p_1 , ... p_n are named parameters , and e is an expression which denotes the result of the function. You can also specify the result type of the function by writing \\func f p_1 ... p_n : T = e , where T is an expression which denotes the result type. In this case, e must have type T . Often the typechecker can infer the result type, so usually you don't have to specify it explicitly. For example, to define the identity function on type A , write the following code: \\func id (x : A) = x A function with three parameters that returns the second one can be defined as follows: \\func second (x : A) (y : B) (z : C) = y You can explicitly specify the result types of these functions. The definitions above are equivalent to the following definitions: \\func id (x : A) : A = x \\func second (x : A) (y : B) (z : C) : B = y Parameters of a function may appear in its body and in its result type. Pattern matching Functions can be defined by recursion. If D is a data type with constructors con1 and con2 Nat . Then you can define a function which maps D to natural numbers in such a way that con1 is mapped to 0 and con2 n is mapped to suc n : \\func f (d : D) : Nat | con1 = 0 | con2 n = suc n The result type of a recursive function must be specified explicitly. The general form of a recursive function is \\func f (x_1 : T_1) ... (x_n : T_n) : R | p^1_1, ... p^1_n = e_1 ... | p^k_1, ... p^k_n = e_k where p^i_j is a pattern of type T_i and e_i is an expression of type R[p^i_1/x_1, ... p^i_n/x_n] (see this section for the discussion of the substitution operation and types of expressions). Note that variables x_1 , ... x_n are not visible in expressions e_i . If a pattern p^i_j contains a variable x as a subpattern of type T , then this variable may appear in expression e_i and it will have the type T . If some of the parameters of f are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . A pattern of type T can have one of the following forms: A variable. If this variable is not used anywhere, its name can be replaces with _ . con s_1 ... s_m , where con (y_1 : A_1) ... (y_m : A_m) is a constructor of a data type D and s_1 ... s_m are patterns. In this case, T must be equal to D and pattern s_i must have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If some of the parameters of con are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . (s_1, ... s_m) , where s_1 ... s_m are patterns. In this case, T must be either a Sigma type with parameters (y_1 : A_1) ... (y_m : A_m) or a class (or a record ) with fields y_1 : A_1 , ... y_m : A_m . The pattern s_i will have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If m equals to 0, then T also may be a data type without constructors. In this case, the right hand side = e_i of the clause in which such a pattern appears must be omitted. Now, let us discuss how expressions of the form f a_1 ... a_n evaluate (see this section for the definition of the reduction and evaluation relations). To reduce an expression E = f a_1 ... a_n , we first evaluate expressions a_1 , ... a_n and match them with the patterns in the definition of f top to bottom, left to right. If all patterns p^i_1 , ... p^i_n matches with a_1 , ... a_n for some i, then E reduces to e_i[b_1/y_1, ... b_k/y_k] , where y_1 , ... y_k are variables that appear in p^i_1 , ... p^i_n and b_1 , ... b_k are subexpressions of a_1 , ... a_n corresponding to these variables. If some argument cannot be matched with a pattern con s_1 ... s_m because it is of the form con' ... for some constructor con' different from con , then the evaluator skips the clause with this patterns and tries the next one. If some argument cannot be matched with a pattern because it is not a constructor, then E does not reduce. If none of the clauses match with arguments, then E also does not reduce. Variables and patterns of the form (s_1, ... s_m) match with any expression. Let us consider an example. Let B be a data type with two constructors T and F . Consider the following function: \\func g (b b' : B) : Nat | T, _ = 0 | _, T = 1 | _, _ = 2 Let x be a variable and let e be an arbitrary expression. If the first argument of g a_1 a_2 is T , then the expression reduces to 0 , if it is x , then expression does not reduce since the first pattern fails to match with x . If the first argument is F , then the evaluator tries to match the second argument: g T e = 0 g x e -- does not reduce g F T = 1 g F F = 2 g F x -- does not reduce You can also write \\func f p_1 ... p_n : R \\with { | c_1 ... | c_n } . The keyword \\with and curly braces are optional and do not affect the defined function. Elim It is often true that we only need to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters. Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient. In this case, we can use the \\elim construction: \\func f (x_1 : A_1) ... (x_n : A_n) : R \\elim x_{i_1}, ... x_{i_m} | p^1_1, ... p^1_m = e_1 ... | p^k_1, ... p^k_m = e_k where i_1, ... i_m are integers such that 1 \u2264 i_1 ... i_m \u2264 n. In this case, parameters x_{i_1} , ... x_{i_m} are eliminated and are not visible in expressions e_1 , ... e_k . Other parameters of f are still visible in these expressions. Note that it does not matter whether a parameter x_i is explicit or implicit when it is eliminated; the corresponding pattern is always explicit. As an example, consider the following function which chooses one of its arguments depending on the value of its other argument: \\func if (b : B) (t e : X) : X \\elim b | T = t | F = e Recursive functions Functions defined by pattern matching can be recursive. That is, if f is a function as described above, then a reference to f may occur inside expressions e_1 , ... e_k . Every function in Arend is a total function. Thus, not every recursive definition is allowed. In order for such a definition to be valid, the recursion must be structural . This roughly means that the arguments to recursive calls of f must be subexpressions of the arguments to the function itself. Function may also be mutually recursive. That is, we can have several functions which refer to each other. In this case, there must be a linear order on the set of these functions f_1 , ... f_n such that the signature of f_i refers only to previous functions. The bodies of the functions may refer to each other as long as the whole recursive system is structural. Copattern matching If the result type of a function is a record or a class, then a function can also be define by copattern matching which has the following syntax: \\func f (x_1 : A_1) ... (x_n : A_n) : C \\cowith | c_1 ... | c_k where c_1 , ... c_k are coclauses . See this section for a definition of coclauses. Such a function has the same semantics as a definition of an instance as described there. It also can be equivalently written as follows: \\func f (x_1 : A_1) ... (x_n : A_n) = \\new C { | c_1 ... | c_k } See this section for the description of the involved constructions.","title":"Function Definitions"},{"location":"language-reference/definitions/functions/#non-recursive-functions","text":"To define a non-recursive function, write \\func f p_1 ... p_n = e , where f is the name of the function, p_1 , ... p_n are named parameters , and e is an expression which denotes the result of the function. You can also specify the result type of the function by writing \\func f p_1 ... p_n : T = e , where T is an expression which denotes the result type. In this case, e must have type T . Often the typechecker can infer the result type, so usually you don't have to specify it explicitly. For example, to define the identity function on type A , write the following code: \\func id (x : A) = x A function with three parameters that returns the second one can be defined as follows: \\func second (x : A) (y : B) (z : C) = y You can explicitly specify the result types of these functions. The definitions above are equivalent to the following definitions: \\func id (x : A) : A = x \\func second (x : A) (y : B) (z : C) : B = y Parameters of a function may appear in its body and in its result type.","title":"Non-recursive functions"},{"location":"language-reference/definitions/functions/#pattern-matching","text":"Functions can be defined by recursion. If D is a data type with constructors con1 and con2 Nat . Then you can define a function which maps D to natural numbers in such a way that con1 is mapped to 0 and con2 n is mapped to suc n : \\func f (d : D) : Nat | con1 = 0 | con2 n = suc n The result type of a recursive function must be specified explicitly. The general form of a recursive function is \\func f (x_1 : T_1) ... (x_n : T_n) : R | p^1_1, ... p^1_n = e_1 ... | p^k_1, ... p^k_n = e_k where p^i_j is a pattern of type T_i and e_i is an expression of type R[p^i_1/x_1, ... p^i_n/x_n] (see this section for the discussion of the substitution operation and types of expressions). Note that variables x_1 , ... x_n are not visible in expressions e_i . If a pattern p^i_j contains a variable x as a subpattern of type T , then this variable may appear in expression e_i and it will have the type T . If some of the parameters of f are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . A pattern of type T can have one of the following forms: A variable. If this variable is not used anywhere, its name can be replaces with _ . con s_1 ... s_m , where con (y_1 : A_1) ... (y_m : A_m) is a constructor of a data type D and s_1 ... s_m are patterns. In this case, T must be equal to D and pattern s_i must have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If some of the parameters of con are implicit, corresponding patterns must be omitted. They can be specified explicitly by surrounding them in { } . (s_1, ... s_m) , where s_1 ... s_m are patterns. In this case, T must be either a Sigma type with parameters (y_1 : A_1) ... (y_m : A_m) or a class (or a record ) with fields y_1 : A_1 , ... y_m : A_m . The pattern s_i will have type A_i[s_1/y_1, ... s_{i-1}/y_{i-1}] . If m equals to 0, then T also may be a data type without constructors. In this case, the right hand side = e_i of the clause in which such a pattern appears must be omitted. Now, let us discuss how expressions of the form f a_1 ... a_n evaluate (see this section for the definition of the reduction and evaluation relations). To reduce an expression E = f a_1 ... a_n , we first evaluate expressions a_1 , ... a_n and match them with the patterns in the definition of f top to bottom, left to right. If all patterns p^i_1 , ... p^i_n matches with a_1 , ... a_n for some i, then E reduces to e_i[b_1/y_1, ... b_k/y_k] , where y_1 , ... y_k are variables that appear in p^i_1 , ... p^i_n and b_1 , ... b_k are subexpressions of a_1 , ... a_n corresponding to these variables. If some argument cannot be matched with a pattern con s_1 ... s_m because it is of the form con' ... for some constructor con' different from con , then the evaluator skips the clause with this patterns and tries the next one. If some argument cannot be matched with a pattern because it is not a constructor, then E does not reduce. If none of the clauses match with arguments, then E also does not reduce. Variables and patterns of the form (s_1, ... s_m) match with any expression. Let us consider an example. Let B be a data type with two constructors T and F . Consider the following function: \\func g (b b' : B) : Nat | T, _ = 0 | _, T = 1 | _, _ = 2 Let x be a variable and let e be an arbitrary expression. If the first argument of g a_1 a_2 is T , then the expression reduces to 0 , if it is x , then expression does not reduce since the first pattern fails to match with x . If the first argument is F , then the evaluator tries to match the second argument: g T e = 0 g x e -- does not reduce g F T = 1 g F F = 2 g F x -- does not reduce You can also write \\func f p_1 ... p_n : R \\with { | c_1 ... | c_n } . The keyword \\with and curly braces are optional and do not affect the defined function.","title":"Pattern matching"},{"location":"language-reference/definitions/functions/#elim","text":"It is often true that we only need to pattern match on a single parameter of a function (or a few parameters), but the function has much more parameters. Then we need to repeat parameters on which we do not pattern match in each clause, which is inconvenient. In this case, we can use the \\elim construction: \\func f (x_1 : A_1) ... (x_n : A_n) : R \\elim x_{i_1}, ... x_{i_m} | p^1_1, ... p^1_m = e_1 ... | p^k_1, ... p^k_m = e_k where i_1, ... i_m are integers such that 1 \u2264 i_1 ... i_m \u2264 n. In this case, parameters x_{i_1} , ... x_{i_m} are eliminated and are not visible in expressions e_1 , ... e_k . Other parameters of f are still visible in these expressions. Note that it does not matter whether a parameter x_i is explicit or implicit when it is eliminated; the corresponding pattern is always explicit. As an example, consider the following function which chooses one of its arguments depending on the value of its other argument: \\func if (b : B) (t e : X) : X \\elim b | T = t | F = e","title":"Elim"},{"location":"language-reference/definitions/functions/#recursive-functions","text":"Functions defined by pattern matching can be recursive. That is, if f is a function as described above, then a reference to f may occur inside expressions e_1 , ... e_k . Every function in Arend is a total function. Thus, not every recursive definition is allowed. In order for such a definition to be valid, the recursion must be structural . This roughly means that the arguments to recursive calls of f must be subexpressions of the arguments to the function itself. Function may also be mutually recursive. That is, we can have several functions which refer to each other. In this case, there must be a linear order on the set of these functions f_1 , ... f_n such that the signature of f_i refers only to previous functions. The bodies of the functions may refer to each other as long as the whole recursive system is structural.","title":"Recursive functions"},{"location":"language-reference/definitions/functions/#copattern-matching","text":"If the result type of a function is a record or a class, then a function can also be define by copattern matching which has the following syntax: \\func f (x_1 : A_1) ... (x_n : A_n) : C \\cowith | c_1 ... | c_k where c_1 , ... c_k are coclauses . See this section for a definition of coclauses. Such a function has the same semantics as a definition of an instance as described there. It also can be equivalently written as follows: \\func f (x_1 : A_1) ... (x_n : A_n) = \\new C { | c_1 ... | c_k } See this section for the description of the involved constructions.","title":"Copattern matching"},{"location":"language-reference/definitions/hits/","text":"Higher Inductive Types TODO","title":"Higher Inductive Types"},{"location":"language-reference/definitions/instances/","text":"Instances TODO","title":"Instances"},{"location":"language-reference/definitions/modules/","text":"Modules Every definition defined in a file is visible anywhere in this file. That is, the order of definitions does not matter. The module system allows you to define definitions in other namespaces. Modules A module consists of a name and a list of definitions: \\module Mod \\where { def_1 ... def_n } You can refer to definitions def_1 ... def_n inside module Mod by their names. To refer to them outside this module, you need to use their full names Mod.def_1 ... Mod.def_n . For example, consider the following code: \\func f2 = Mod.f1 \\module Mod \\where { \\func f1 = f2 \\func f2 = 0 \\func f3 = f4 } \\func f4 = f2 You cannot refer to f1 in f2 without Mod. prefix. Function f4 refers to f2 defined on the top level. Function Mod.f2 hides the top level f2 inside module Mod , so Mod.f1 refers to Mod.f2 . You can refer to top level functions inside modules as shown in the example where Mod.f3 refers to f4 . If a \\where block contains a single definition, you can omit curly braces. Where blocks Every definition has an associated module with the same name. To add definitions to this module, you can write the \\where block at the end of this definition. Definitions defined in the associated module of a definition are visible inside this definition. \\func f = g \\where \\func g = 0 \\func h = f.g \\where \\data D \\where { \\func k = D \\func s = M.g.N.s } \\module M \\where \\func g = N.s \\where { \\module N \\where { \\func s = E } \\data E } Constructors of a \\data definition and fields of a \\class or a \\record definition are defined inside the module associated to the definition, but they are also visible outside this module. Open commands A module can be opened. This makes definitions defined inside this module visible in the current scope. The \\open command affects all definitions in the current scope. \\func h1 = f \\module M \\where { \\func f = 0 \\func g = 1 } \\open M \\func h2 = g The command \\open M (def_1, ... def_n) opens only definitions def_1 , ... def_n . Other definitions must be refered to by their full names. The command \\open M \\hiding (def_1, ... def_n) opens all of the definitions of M except for def_1 , ... def_n . These definitions still can be refered to by their full names. The command \\open M (def_1 \\as def_1', ... def_n \\as def_n') opens definitions def_1 , ... def_n , but renames them to def_1' , ... def_n' , respectively. If you want to open all of the definitions and rename some of them, use the command \\open M \\using (def_1 \\as def_1', ... def_n \\as def_n') . \\module M \\where { \\func f = 0 \\func g = 1 \\func h = 2 } \\module M1 \\where { \\open M (f,g) \\func h1 = f \\func h2 = g \\func h3 = M.h -- we can refer to M.h only by its full name. } \\module M2 \\where { \\open M \\hiding (f,g) \\func h1 = M.f -- we can refer to M.f and M.g only by their full names. \\func h2 = M.g \\func h3 = h } \\module M3 \\where { \\open M1 (h1 \\as M1_h1, h2) \\open M2 \\using (h2 \\as M2_h2) \\hiding (h3) \\func k1 = M1_h1 -- this refers to M1.h1 \\func k2 = h1 -- this refers to M2.h1 \\func k3 = h2 -- this refers to M1.h2 \\func k4 = M2_h2 -- this refers to M2.h2 \\func k5 = M1.h3 -- we can refer to M1.h3 only by its full name. } Note that if you open a module M inside a module M' and then open M' inside M'' , then definitions from M will not be visible in M'' . You need to explicitly open M inside M'' to make them visible. Import commands If you have several files, you can use the \\import command to make one of them visible in the other. For example, suppose that we have files A.ard , B.ard , a directory Dir , and a file Dir/C.ard with the following content: -- A.ard \\func a1 = 0 \\func a2 = 0 \\where \\func a3 = 0 -- Dir/C.ard \\import A \\func c1 = a1 \\func c2 = a2.a3 -- B.ard \\import Dir.C \\func b1 = c1 -- \\func b2 = a1 -- definitions from file A are not visible -- \\func b3 = A.a1 -- you cannot refer to definitions from file A by their full names. \\func b4 = Dir.C.c2 -- you can refer to definitions from file Dir/C.ard by their full names. The \\import command also opens the content of the imported file. You can use the same syntax as for \\open commands to control which definitions will be opened. If you want only import a file and not open any definitions, you can write \\import X () . Then you can refer to definitions defined in file X by their full names: -- X.ard \\func f = 0 -- Y.ard \\import X() \\func f = X.f","title":"Modules"},{"location":"language-reference/definitions/modules/#modules","text":"A module consists of a name and a list of definitions: \\module Mod \\where { def_1 ... def_n } You can refer to definitions def_1 ... def_n inside module Mod by their names. To refer to them outside this module, you need to use their full names Mod.def_1 ... Mod.def_n . For example, consider the following code: \\func f2 = Mod.f1 \\module Mod \\where { \\func f1 = f2 \\func f2 = 0 \\func f3 = f4 } \\func f4 = f2 You cannot refer to f1 in f2 without Mod. prefix. Function f4 refers to f2 defined on the top level. Function Mod.f2 hides the top level f2 inside module Mod , so Mod.f1 refers to Mod.f2 . You can refer to top level functions inside modules as shown in the example where Mod.f3 refers to f4 . If a \\where block contains a single definition, you can omit curly braces.","title":"Modules"},{"location":"language-reference/definitions/modules/#where-blocks","text":"Every definition has an associated module with the same name. To add definitions to this module, you can write the \\where block at the end of this definition. Definitions defined in the associated module of a definition are visible inside this definition. \\func f = g \\where \\func g = 0 \\func h = f.g \\where \\data D \\where { \\func k = D \\func s = M.g.N.s } \\module M \\where \\func g = N.s \\where { \\module N \\where { \\func s = E } \\data E } Constructors of a \\data definition and fields of a \\class or a \\record definition are defined inside the module associated to the definition, but they are also visible outside this module.","title":"Where blocks"},{"location":"language-reference/definitions/modules/#open-commands","text":"A module can be opened. This makes definitions defined inside this module visible in the current scope. The \\open command affects all definitions in the current scope. \\func h1 = f \\module M \\where { \\func f = 0 \\func g = 1 } \\open M \\func h2 = g The command \\open M (def_1, ... def_n) opens only definitions def_1 , ... def_n . Other definitions must be refered to by their full names. The command \\open M \\hiding (def_1, ... def_n) opens all of the definitions of M except for def_1 , ... def_n . These definitions still can be refered to by their full names. The command \\open M (def_1 \\as def_1', ... def_n \\as def_n') opens definitions def_1 , ... def_n , but renames them to def_1' , ... def_n' , respectively. If you want to open all of the definitions and rename some of them, use the command \\open M \\using (def_1 \\as def_1', ... def_n \\as def_n') . \\module M \\where { \\func f = 0 \\func g = 1 \\func h = 2 } \\module M1 \\where { \\open M (f,g) \\func h1 = f \\func h2 = g \\func h3 = M.h -- we can refer to M.h only by its full name. } \\module M2 \\where { \\open M \\hiding (f,g) \\func h1 = M.f -- we can refer to M.f and M.g only by their full names. \\func h2 = M.g \\func h3 = h } \\module M3 \\where { \\open M1 (h1 \\as M1_h1, h2) \\open M2 \\using (h2 \\as M2_h2) \\hiding (h3) \\func k1 = M1_h1 -- this refers to M1.h1 \\func k2 = h1 -- this refers to M2.h1 \\func k3 = h2 -- this refers to M1.h2 \\func k4 = M2_h2 -- this refers to M2.h2 \\func k5 = M1.h3 -- we can refer to M1.h3 only by its full name. } Note that if you open a module M inside a module M' and then open M' inside M'' , then definitions from M will not be visible in M'' . You need to explicitly open M inside M'' to make them visible.","title":"Open commands"},{"location":"language-reference/definitions/modules/#import-commands","text":"If you have several files, you can use the \\import command to make one of them visible in the other. For example, suppose that we have files A.ard , B.ard , a directory Dir , and a file Dir/C.ard with the following content: -- A.ard \\func a1 = 0 \\func a2 = 0 \\where \\func a3 = 0 -- Dir/C.ard \\import A \\func c1 = a1 \\func c2 = a2.a3 -- B.ard \\import Dir.C \\func b1 = c1 -- \\func b2 = a1 -- definitions from file A are not visible -- \\func b3 = A.a1 -- you cannot refer to definitions from file A by their full names. \\func b4 = Dir.C.c2 -- you can refer to definitions from file Dir/C.ard by their full names. The \\import command also opens the content of the imported file. You can use the same syntax as for \\open commands to control which definitions will be opened. If you want only import a file and not open any definitions, you can write \\import X () . Then you can refer to definitions defined in file X by their full names: -- X.ard \\func f = 0 -- Y.ard \\import X() \\func f = X.f","title":"Import commands"},{"location":"language-reference/definitions/parameters/","text":"Parameters Most kinds of definitions can have parameters. A parameter can be named or unnamed, explicit or implicit. Implicit parameters are always named. An unnamed parameter is simply an expression which denotes the type of the parameter. Syntax A named explicit parameter has the form (x : T) , where x is the name of the parameter and T is an expression which denotes the type of the parameter. An implicit parameter has the form {x : T} , where x and T are the same as before. Parameters are specified after the name of a definition. For example, all of the definitions below have three parameters: x1 of type A1 , x2 of type A2 , and x3 of type A3 . \\func f {x1 : A1} {x2 : A2} {x3 : A3} = 0 \\data D (x1 : A1) (x2 : A2) (x3 : A3) \\class C (x1 : A1) {x2 : A2} (x3 : A3) If several consecutive parameters have the same type, it can be specified only once by using the following syntax: x_1 ... x_n : T . For example, the following function has two implicit parameters of type A1 , three explicit parameters of type A2 , and one explicit parameter of type A3 : \\func f {x1 x2 : A1} (y1 y2 y3 : A2) (z : A3) = 0 This definition is equivalent to the following one: \\func f {x1 : A1} {x2 : A1} (y1 : A2) (y2 : A2) (y3 : A2) (z : A3) = 0 Parameters can be refered from the types of subsequent parameters and from the body of the definition. In the example above, parameters x1 and x2 may appear in A2 and A3 , parameters y1 , y2 , and y3 may appear in A3 , and all of the parameters may appear in the expression after = . If a pattern is never used anywhere, its name can be replaced with _ . Such a name cannot be refered to, so this simply indicated that this parameter is ignored. Implicit arguments Let f be a definition with parameters of types A_1 , ... A_n . If all of the parameters are explicit, then to we can form an expression of the form f a_1 ... a_n , where a_i is an expression of type A_i . Such an expression invokes f with the specified arguments. If some of the parameters of f are implicit, then corresponding arguments must be omitted. For example, consider the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f a1 a3 In the expression f a1 a3 , arguments corresponding to parameters y , y' , and z are omitted. The typechecker tries to infer these parameters and reports an error if it fails to do so. We can ask typechecker to try to infer an explicit parameter by writing _ instead of the corresponding argument: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ a3 In the example above, the typechecker will try to infer the argument corresponding to x . The expression _ can be written actually anywhere at all. The typechecker infers omitted expressions only when there is a unique solution that makes the definition in which they appear to typecheck. Finally, if the typechecker cannot infer an implicit argument, it can be specified explicitly by writing {e} . For example, to specify explicitly the second and the last arguments of f , we can write the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ {a2} a3 {a4} In this example, arguments corresponding to x and y' are left implicit and other arguments are explicitly specified. If op is an infix operator, then we can write x op {a_1} ... {a_n} y , which is equivalent to op {a_1} ... {a_n} x y . That is, implicit arguments which are written immediately after an infix operator are considered to be its first arguments.","title":"Parameters"},{"location":"language-reference/definitions/parameters/#syntax","text":"A named explicit parameter has the form (x : T) , where x is the name of the parameter and T is an expression which denotes the type of the parameter. An implicit parameter has the form {x : T} , where x and T are the same as before. Parameters are specified after the name of a definition. For example, all of the definitions below have three parameters: x1 of type A1 , x2 of type A2 , and x3 of type A3 . \\func f {x1 : A1} {x2 : A2} {x3 : A3} = 0 \\data D (x1 : A1) (x2 : A2) (x3 : A3) \\class C (x1 : A1) {x2 : A2} (x3 : A3) If several consecutive parameters have the same type, it can be specified only once by using the following syntax: x_1 ... x_n : T . For example, the following function has two implicit parameters of type A1 , three explicit parameters of type A2 , and one explicit parameter of type A3 : \\func f {x1 x2 : A1} (y1 y2 y3 : A2) (z : A3) = 0 This definition is equivalent to the following one: \\func f {x1 : A1} {x2 : A1} (y1 : A2) (y2 : A2) (y3 : A2) (z : A3) = 0 Parameters can be refered from the types of subsequent parameters and from the body of the definition. In the example above, parameters x1 and x2 may appear in A2 and A3 , parameters y1 , y2 , and y3 may appear in A3 , and all of the parameters may appear in the expression after = . If a pattern is never used anywhere, its name can be replaced with _ . Such a name cannot be refered to, so this simply indicated that this parameter is ignored.","title":"Syntax"},{"location":"language-reference/definitions/parameters/#implicit-arguments","text":"Let f be a definition with parameters of types A_1 , ... A_n . If all of the parameters are explicit, then to we can form an expression of the form f a_1 ... a_n , where a_i is an expression of type A_i . Such an expression invokes f with the specified arguments. If some of the parameters of f are implicit, then corresponding arguments must be omitted. For example, consider the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f a1 a3 In the expression f a1 a3 , arguments corresponding to parameters y , y' , and z are omitted. The typechecker tries to infer these parameters and reports an error if it fails to do so. We can ask typechecker to try to infer an explicit parameter by writing _ instead of the corresponding argument: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ a3 In the example above, the typechecker will try to infer the argument corresponding to x . The expression _ can be written actually anywhere at all. The typechecker infers omitted expressions only when there is a unique solution that makes the definition in which they appear to typecheck. Finally, if the typechecker cannot infer an implicit argument, it can be specified explicitly by writing {e} . For example, to specify explicitly the second and the last arguments of f , we can write the following code: \\func f (x : A1) {y y' : A2} (z : A3) {z : A4} = 0 \\func g = f _ {a2} a3 {a4} In this example, arguments corresponding to x and y' are left implicit and other arguments are explicitly specified. If op is an infix operator, then we can write x op {a_1} ... {a_n} y , which is equivalent to op {a_1} ... {a_n} x y . That is, implicit arguments which are written immediately after an infix operator are considered to be its first arguments.","title":"Implicit arguments"},{"location":"language-reference/definitions/records/","text":"Records TODO","title":"Records"},{"location":"language-reference/expressions/case/","text":"Case The basic syntax of case expressions looks like this: \\case e_1, ... e_n \\with { | p_1^1, ... p_n^1 = d_1 ... | p_1^k, ... p_n^k = d_k } where e_1 , ... e_n , d_1 , ... d_k are expressions and p_1^1 , ... p_n^k are patterns. Such an expression reduces in the same way as functions defined by pattern matching (see this section ). If the typechecker does not know the type of a case expression, it must be specified explicitly: \\case e_1, ... e_n \\return T \\with { ... } . The general syntax of case expressions looks like this: \\case e_1 \\as x_1 : E_1, ... e_n \\as x_n : E_n \\return T \\with { ... } , where x_1 , ... x_n are variables and E_1 , ... E_n are expressions. The parts \\as x_i and : E_i can be omitted. Expressions E_i can refer to x_1 , ... x_{i-1} and T can refer to x_1 , ... x_n . In this case, e_i must have type E_i[e_1/x_1, ... e_{i-1}/x_{i-1}] . The type of the case expression is T[e_1/x_1, ... e_n/x_n] .","title":"Case"},{"location":"language-reference/expressions/class-ext/","text":"Class extensions TODO","title":"Class extensions"},{"location":"language-reference/expressions/goals/","text":"Goals A goal marks an unfinished expression. It always produce an error message which contains the expected type of a expression that should replace the goal and the context of the goal, that is the list of available variables with their types. A goal is writen as {?} or {?id} , where id is any identifier which denotes the name of the goal. The name of a goal only appears in error messages and does not affect the code in any way. For example, consider the following code: \\func f (x y : Nat) (p : x = y) : y = x = {?} It will produce the following error message: [GOAL] test.ard:1:44: Expected type: y = {Nat} x Context: y : Nat x : Nat p : x = {Nat} y In: {?} While processing: f The information in the error message might be even more useful when the expected type or types of variables are inferred by the typechecker.","title":"Goals"},{"location":"language-reference/expressions/let/","text":"Let Let expressions allow us to introduce local variables. Such expressions have the following syntax: \\let | x_1 = e_1 ... | x_n = e_n \\in e_{n+1} where x_1 , ... x_n are variables and e_1 , ... e_{n+1} are expressions. Expression e_{i+1} can refer to variables x_1 , ... x_i . You can also write lambda parameters after the name of the variable. That is, instead of | x_i = e_i , you can write | x_i p^i_1 ... p^i_{n_i} = e_i , where p^i_1 , ... p^i_{n_i} are either variables or named parameters to which e_i can refer. Such a clause is equivalent to | x_i = \\lam p^i_1 ... p^i_{n_i} = e_i . The expression \\let | x_1 = e_1 ... | x_n = e_n \\in e reduces to e[e_1/x_1, ... e_n/x_n] . Its type is \\let | x_1 = e_1 ... | x_n = e_n \\in E , where E is the type of e .","title":"Let"},{"location":"language-reference/expressions/pi/","text":"Pi Types A pi type is a type of (dependent) functions. If p_1 , ... p_n are named or unnamed parameters and B is a type, then \\Pi p_1 ... p_n - B is also a type. If B does not refer to variables defined in the parameters, you can write A_1 - ... A_n - B instead, where A_i are types of the parameters. If A_i has type \\Type p_i h_i and B has type \\Type p h , then the type of the pi type is \\Type p_max h , where p_max is the maximum of p_1 , ... p_n , and p . Note that the homotopy level of the pi type is simply the homotopy level of the codomain. An expression of the form \\Pi p_1 ... p_n - B is equivalent to \\Pi p_1 - \\Pi p_2 ... p_n - B . Moreover, if p_1 equals to (x_1 ... x_k : A) , then it is also equivalent to \\Pi (x_1 : A) - \\Pi (x_2 ... x_k : A) - \\Pi p_2 ... p_n - B . A lambda parameter is either a variable or a named parameter. If p_1 , ... p_n is a sequence of lambda parameters and e is an expression of type E , then \\lam p_1 ... p_n = e is an expression which has type \\Pi p_1 ... p_n - E . If some paramters miss types, then they will be inferred by the typechecker. If f is an expression of type \\Pi (x : A) - B and a is an expression of type A , then f a is an expression of type B[a/x] . An expression of the form (\\lam x = b) a reduces to b[a/x] .","title":"Pi Types"},{"location":"language-reference/expressions/sigma/","text":"Sigma Types A sigma type is a type of (dependent) tuples. If p_1 , ... p_n are named or unnamed parameters, then \\Sigma p_1 ... p_n is also a type. If A_i has type \\Type p_i h_i , then the type of the sigma type is \\Type p_max h_max , where p_max is the maximum of p_1 , ... p_n and h_max is the maximum of h_1 , ... h_n . An expression of the form \\Sigma p_1 ... p_n (x_1 ... x_k : A) q_1 ... q_m is equivalent to \\Sigma p_1 ... p_n (x_1 : A) ... (x_k : A) q_1 ... q_m . If a_i is an expression of type A_i[a_1/x_1, ... a_{i-1}/x_{i-1}] , then (a_1, ... a_n) is an expression of type \\Sigma (x_1 : A_1) ... (x_n : A_n) . Note that the typechecker often cannot infer the correct type of such an expression. If it does not know it already, it always infer the non-dependent version. In this case, you can simply specify the type explicitly: ((a_1, ... a_n) : \\Sigma (x_1 : A_1) ... (x_n : A_n)) . You can also explicitly specify type of each field: (b_1 : B_1, ... b_n : B_n) , but B_i cannot refer to previous parameters, so this allows you to define only non-dependent sigma types. If p is an expression of type \\Sigma (x_1 : A_1) ... (x_n : A_n) and 1 \u2264 i \u2264 n, then p.i is an expression of type A_i[p.1/x_1, ... p_{i-1}/x_{i-1}] . An expression of the form (a_1, ... a_n).i reduces to a_i .","title":"Sigma Types"},{"location":"language-reference/expressions/universes/","text":"Universes A universe is a type of types. Since we cannot assume that there exists a type of all types, we assume a hierarchy of universes. That is, we have a universe \\Type0 which contains all types that do not mention universes, a universe \\Type1 which contains all types that might mention only \\Type0 , and so on. Thus, for every natural number n, we have an expression \\Type n (the whitespace is optional). This number is called the predicative level of the universe. The expression \\Type n has type \\Type (n+1) . Universes are cumulative, that is every expression of type \\Type n also has type \\Type (n+1) . Homotopy levels Universes are actually parameterized by two levels. The other one is called the homotopy level . The universe of predicative level p and homotopy level h is denote by \\h-Type p . The homotopy level h is a number such that -1 \u2264 h \u2264 \u221e. If h equals to \u221e, then we write \\oo-Type p . If h equals to -1, then the universe does not have a predicative level and it is denoted by \\Prop . The expression \\h-Type p has type \\(h+1)-Type (p+1) if 0 \u2264 h \u221e. The expression \\Prop has type \\0-Type 0 . The expression \\oo-Type p has type \\oo-Type (p+1) . Universes of the form \\0-Type p can also be denoted by \\Set p . The homotopy level can be also specified after the predicative level. That is, we can write \\Type p h instead of \\h-Type p Level polymorphism Every definition is considered polymorphic in both levels. That is, every definition has two additional parameters: one for a predicative level and one for a homotopy level. These parameters are denoted by \\lp and \\lh respectively. You can explicitly specify level arguments in a defcall by writing \\levels p h , where p and h are level expressions of the corresponding kind. Keyword \\levels can be often omitted (if the resulting expression is unambiguous). To specify the \\Prop level, write \\levels \\Prop . Level expressions are defined inductively: \\lp is a level expression of the predicative kind and \\lh is a level expression of the homotopy kind. A constant (that is, a natural number) is a level expression of both kinds. There is also constant \\inf for homotopy levels. _ is a level expression of both kinds. Such an expression tells the typechecker to infer the expression. If l is a level expression, then \\suc l is also a level expression of the same kind as l. If l1 and l2 are level expressions of the same kind, then \\max l1 l2 is also a level expression of the same kind as l1 and l2. Since the only level variables are \\lp and \\lh , the expression \\max l1 l2 is useful only when one of the levels is a constant. Level inference The level arguments to a function are often can be inferred automatically. Moreover, both levels of a universe can also be omitted, in which case they are also will be inferred by the typechecker. The typechecker always tries to infer the minimal level which mentions either \\lp or \\lh if possible. Consider, for example, the following code which defines the identity function: \\func id {A : \\Type} (a : A) = a The minimal appropriate level (both predicative and homotopy) of the universe \\Type in the definition of this function is 0, but it is also possible to use levels \\lp and \\lh , so this function is equivalent to the following one: \\func id' {A : \\Type \\lp \\lh} (a : A) = a Let us give a few more examples. We write a definition and an equivalent definition with explicitly specified levels below it. \\data Either (A B : \\Type) | inl A | inr B \\data Either' (A B : \\Type \\lp \\lh) | inl A | inr B \\func f = id \\Type \\func f' = id (\\suc \\lp) (\\suc \\lh) (\\Type \\lp \\lh) \\func fromEither {A : \\Type} (e : Either A \\Type) : \\Type \\elim e | inl a = A | inr X = X \\func fromEither' {A : \\Type \\lp \\lh} (e : Either (\\suc \\lp) (\\suc \\lh) A (\\Type \\lp \\lh)) : \\Type \\lp \\lh \\elim e | inl a = A | inr X = X The levels in parameters and in the result type of a recursive function are inferred before levels in the body. This means that the following function will not typecheck. \\func eitherToType {A : \\Type} (e : Either A A) : \\Type | inl _ = \\Type | inr _ = \\Type We can explicitly specify the levels of the universe that appears in the result type to fix this problem: \\func eitherToTypeFixed {A : \\Type} (e : Either A A) : \\Type (\\suc \\lp) (\\suc \\lh) | inl _ = \\Type | inr _ = \\Type \\func eitherToTypeFixed' {A : \\Type \\lp \\lh} (e : Either \\lp \\lh A A) : \\Type (\\suc \\lp) (\\suc \\lh) | inl _ = \\Type \\lp \\lh | inr _ = \\Type \\lp \\lh If we specify constant levels instead as shown below, then the function also will typecheck, but the levels of universes in the body will also be constant: \\func eitherToTypeConstant {A : \\Type} (e : Either A A) : \\3-Type 7 | inl _ = \\Type | inr _ = \\Type \\func eitherToTypeConstant' {A : \\Type \\lp \\lh} (e : Either \\lp \\lh A A) : \\3-Type 7 | inl _ = \\Set0 | inr _ = \\Set0 Note that homotopy levels inferred by the typechecker are always greater than or equal to 0. Thus, the function eitherToProp does not typecheck even though eitherToPropFixed does: \\func eitherToProp {A : \\Type} (e : Either A A) : \\Set0 | inl _ = \\Type | inr _ = \\Type \\func eitherToPropFixed {A : \\Type} (e : Either A A) : \\Set0 | inl _ = \\Prop | inr _ = \\Prop Levels in the result type of a non-recursive function are inferred together with levels in the body. Thus, the following function typechecks: \\func f : \\Type = \\Type \\func f' : \\Type (\\suc \\lp) (\\suc \\lh) = \\Type \\lp \\lh","title":"Universes"},{"location":"language-reference/expressions/universes/#homotopy-levels","text":"Universes are actually parameterized by two levels. The other one is called the homotopy level . The universe of predicative level p and homotopy level h is denote by \\h-Type p . The homotopy level h is a number such that -1 \u2264 h \u2264 \u221e. If h equals to \u221e, then we write \\oo-Type p . If h equals to -1, then the universe does not have a predicative level and it is denoted by \\Prop . The expression \\h-Type p has type \\(h+1)-Type (p+1) if 0 \u2264 h \u221e. The expression \\Prop has type \\0-Type 0 . The expression \\oo-Type p has type \\oo-Type (p+1) . Universes of the form \\0-Type p can also be denoted by \\Set p . The homotopy level can be also specified after the predicative level. That is, we can write \\Type p h instead of \\h-Type p","title":"Homotopy levels"},{"location":"language-reference/expressions/universes/#level-polymorphism","text":"Every definition is considered polymorphic in both levels. That is, every definition has two additional parameters: one for a predicative level and one for a homotopy level. These parameters are denoted by \\lp and \\lh respectively. You can explicitly specify level arguments in a defcall by writing \\levels p h , where p and h are level expressions of the corresponding kind. Keyword \\levels can be often omitted (if the resulting expression is unambiguous). To specify the \\Prop level, write \\levels \\Prop . Level expressions are defined inductively: \\lp is a level expression of the predicative kind and \\lh is a level expression of the homotopy kind. A constant (that is, a natural number) is a level expression of both kinds. There is also constant \\inf for homotopy levels. _ is a level expression of both kinds. Such an expression tells the typechecker to infer the expression. If l is a level expression, then \\suc l is also a level expression of the same kind as l. If l1 and l2 are level expressions of the same kind, then \\max l1 l2 is also a level expression of the same kind as l1 and l2. Since the only level variables are \\lp and \\lh , the expression \\max l1 l2 is useful only when one of the levels is a constant.","title":"Level polymorphism"},{"location":"language-reference/expressions/universes/#level-inference","text":"The level arguments to a function are often can be inferred automatically. Moreover, both levels of a universe can also be omitted, in which case they are also will be inferred by the typechecker. The typechecker always tries to infer the minimal level which mentions either \\lp or \\lh if possible. Consider, for example, the following code which defines the identity function: \\func id {A : \\Type} (a : A) = a The minimal appropriate level (both predicative and homotopy) of the universe \\Type in the definition of this function is 0, but it is also possible to use levels \\lp and \\lh , so this function is equivalent to the following one: \\func id' {A : \\Type \\lp \\lh} (a : A) = a Let us give a few more examples. We write a definition and an equivalent definition with explicitly specified levels below it. \\data Either (A B : \\Type) | inl A | inr B \\data Either' (A B : \\Type \\lp \\lh) | inl A | inr B \\func f = id \\Type \\func f' = id (\\suc \\lp) (\\suc \\lh) (\\Type \\lp \\lh) \\func fromEither {A : \\Type} (e : Either A \\Type) : \\Type \\elim e | inl a = A | inr X = X \\func fromEither' {A : \\Type \\lp \\lh} (e : Either (\\suc \\lp) (\\suc \\lh) A (\\Type \\lp \\lh)) : \\Type \\lp \\lh \\elim e | inl a = A | inr X = X The levels in parameters and in the result type of a recursive function are inferred before levels in the body. This means that the following function will not typecheck. \\func eitherToType {A : \\Type} (e : Either A A) : \\Type | inl _ = \\Type | inr _ = \\Type We can explicitly specify the levels of the universe that appears in the result type to fix this problem: \\func eitherToTypeFixed {A : \\Type} (e : Either A A) : \\Type (\\suc \\lp) (\\suc \\lh) | inl _ = \\Type | inr _ = \\Type \\func eitherToTypeFixed' {A : \\Type \\lp \\lh} (e : Either \\lp \\lh A A) : \\Type (\\suc \\lp) (\\suc \\lh) | inl _ = \\Type \\lp \\lh | inr _ = \\Type \\lp \\lh If we specify constant levels instead as shown below, then the function also will typecheck, but the levels of universes in the body will also be constant: \\func eitherToTypeConstant {A : \\Type} (e : Either A A) : \\3-Type 7 | inl _ = \\Type | inr _ = \\Type \\func eitherToTypeConstant' {A : \\Type \\lp \\lh} (e : Either \\lp \\lh A A) : \\3-Type 7 | inl _ = \\Set0 | inr _ = \\Set0 Note that homotopy levels inferred by the typechecker are always greater than or equal to 0. Thus, the function eitherToProp does not typecheck even though eitherToPropFixed does: \\func eitherToProp {A : \\Type} (e : Either A A) : \\Set0 | inl _ = \\Type | inr _ = \\Type \\func eitherToPropFixed {A : \\Type} (e : Either A A) : \\Set0 | inl _ = \\Prop | inr _ = \\Prop Levels in the result type of a non-recursive function are inferred together with levels in the body. Thus, the following function typechecks: \\func f : \\Type = \\Type \\func f' : \\Type (\\suc \\lp) (\\suc \\lh) = \\Type \\lp \\lh","title":"Level inference"},{"location":"tutorial/","text":"Tutorial Functions Pattern Matching","title":"Table of Contents"},{"location":"tutorial/functions/","text":"Functions TODO","title":"Functions"},{"location":"tutorial/pattern-matching/","text":"Pattern Matching TODO","title":"Pattern Matching"}]}